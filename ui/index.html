<!doctype html>
<html lang="en" data-theme="cue-light">
<head>
  <meta charset="utf-8" />
  <title>Q-Gen -- Questionnaire & Tab Plan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />  
  <style>
  /* =======================================================
    Q-GEN DESIGN TOKENS & BASE LAYOUT (Step 1 clean refactor)
    - Brand base (stable)
    - Theme tokens (cue-light / cue-dark / cue-gold)
    - Global resets & page chrome (header/nav scaffolding)
    - Non-breaking: same selectors, deduped helpers
    ======================================================= */

  /* ------------------------------
    0) Brand Palette (stable base)
    ------------------------------ */
  :root{
    --brand-primary:   #212161;  /* deep navy */
    --brand-secondary: #F2B800;  /* gold */
    --brand-yellow:    #F4E412;
    --brand-blue-1:    #3F6AB7;
    --brand-blue-2:    #335899;

    --brand-accent-1:  #A7B5DB;  /* soft periwinkle */
    --brand-accent-2:  #8197D0;
    --brand-accent-3:  #E3EAF7;  /* light panel */

    --danger:          #C62828;

    /* spacing / radius tokens used by components down the tree */
    --radius-sm: 8px;
    --radius-md: 10px;
    --radius-lg: 12px;
    --radius-xl: 16px;
    --space-1: 6px;
    --space-2: 8px;
    --space-3: 10px;
    --space-4: 12px;
    --space-5: 14px;
    --space-6: 16px;
  }

  /* ---------------------------------------
    1) Theme Tokens (override by data-theme)
    --------------------------------------- */

  /* Cue Light (DEFAULT) */
  :root[data-theme="cue-light"]{
    --accent:       var(--brand-primary);
    --accent-weak:  #3b3b7d;

    --cta:          var(--brand-secondary);
    --cta-text:     #1a1a1a;

    /* layered surfaces (distant → near) */
    --bg:           #EEF2FB;   /* canvas */
    --surface-3:    #F1F4FB;   /* subtle elevation */
    --surface-2:    #F6F8FD;   /* header / rail */
    --surface-1:    #FFFFFF;   /* cards / inputs */

    --fg:           #0F172A;
    --muted:        #637189;
    --line:         #D9E0EF;
    --ring:         rgba(51,88,153,.35);
    --shadow:       0 8px 24px rgba(15, 23, 42, .06);
  }

  /* Cue Dark */
  :root[data-theme="cue-dark"]{
    --accent:       #A7B5DB;
    --accent-weak:  #8ea1da;

    --cta:          var(--brand-secondary);
    --cta-text:     #101010;

    --bg:           #0A0F24;
    --surface-3:    #101631;
    --surface-2:    #131A35;
    --surface-1:    #151F41;

    --fg:           #E7ECFF;
    --muted:        #A8B2CC;
    --line:         rgba(231,236,255,.10);
    --ring:         rgba(167,181,219,.45);
    --shadow:       0 10px 28px rgba(0,0,0,.35);
  }

  /* Cue Gold (light neutrals; gold CTAs) */
  :root[data-theme="cue-gold"]{
    --accent:       var(--brand-primary);
    --accent-weak:  #3b3b7d;

    --cta:          var(--brand-secondary);
    --cta-text:     #1a1a1a;

    --bg:           #EEF2FB;
    --surface-3:    #F1F4FB;
    --surface-2:    #F6F8FD;
    --surface-1:    #FFFFFF;

    --fg:           #0F172A;
    --muted:        #637189;
    --line:         #D9E0EF;
    --ring:         rgba(51,88,153,.35);
    --shadow:       0 8px 24px rgba(15, 23, 42, .06);
  }

  /* ------------------------------
    2) Global Reset & Typography
    ------------------------------ */
  *, *::before, *::after { box-sizing: border-box; }
  html, body { height: 100%; overflow-x: hidden; }
  body {
    margin:0;
    font: 14px/1.45 'Aptos', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; /* Changed here */
    color: var(--fg);
    background: var(--bg);
    display: flex;
    flex-direction: column;
  }   

  /* shared utility helpers (deduped) */
  .is-hidden { display: none !important; }
  .muted { color:var(--muted); }

  .content-blur { filter: blur(4px); transition: filter .2s ease-out; }

  #view-root { padding-top: 8px; } /* breathing room below sticky bars */

  /* ------------------------------
    3) App Chrome (Header / Nav)
    ------------------------------ */
  header {
    background: var(--surface-2);
    border-bottom: 1px solid var(--line);
    padding: 12px 16px;
    display: flex;
    align-items: center;
    justify-content: space-between; /* keep from prior patch */
    flex-shrink: 0;
    box-shadow: var(--shadow);
  }
  header .logo{ font-size:20px; font-weight:700; }
  header .project-inputs{ display:flex; gap:8px; align-items:center; }
  header .project-inputs input{ padding:6px 10px; width:auto; }
  header .actions{ display:flex; gap:8px; align-items:center; }

  /* Utilities missing but referenced */
  .btn { all: unset; display:inline-flex; align-items:center; gap:6px;
    padding:8px 12px; border:1px solid var(--line); border-radius:10px;
    background:var(--surface-1); color:var(--fg); cursor:pointer; }
  .btn.primary { background:var(--accent); border-color:var(--accent); color:#fff; }
  .btn.ghost { background:transparent; }
  .icon-btn { all: unset; cursor:pointer; padding:4px 8px; border-radius:8px; }
  .grid2 { display:grid; grid-template-columns: 120px 1fr; gap:8px; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

  /* top nav */
  nav.app-nav{
    position: sticky; top: 0; z-index: 50;
    background: var(--surface-2);
    border-bottom: 1px solid var(--line);
    padding: 12px 0;
  }
  .app-nav .nav-inner{
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
  }
  .nav-btn{
    padding: 8px 14px;
    border: 1px solid var(--line);
    border-radius: 999px;
    background: var(--surface-1);
    color: var(--muted);
    font-weight: 600;
    transition: box-shadow .15s, transform .05s;
  }
  .nav-btn:hover{ transform: translateY(-1px); }
  .nav-btn.active{
    color: var(--fg);
    box-shadow: 0 0 0 2px var(--ring);
  }

  /* --- Editor sub-tabs (secondary) --- */
  .subtabs{
    z-index: 45;
    background: var(--surface-2);
    border-bottom: 1px solid var(--line);
    margin-bottom: 16px;
  }
  .subtabs .subtabs-inner{
    max-width: 1200px;
    margin: 0 auto;
    padding: 10px 16px;
    display: flex;
    justify-content: center;
    gap: 8px;
  }
  .subtab{
    padding: 8px 12px;
    border: 1px solid transparent;
    border-bottom: 0;
    border-radius: 8px 8px 0 0; /* Rounded top corners only */
    background: transparent;    /* Make the background subtle */
    color: var(--muted);
    font-weight: 600;
    cursor: pointer;
    transition: all .15s;
    margin-bottom: -1px; /* Helps the active tab blend into the panel */
  }
  .subtab.active{
    color: var(--fg);
    background: var(--surface-1); /* Match the panel background */
    border-color: var(--line);
    box-shadow: none; /* The border is enough emphasis */
  }

  .app-grid > .right-panel > .card {
    border-top: none;
    border-top-left-radius: 0;
  }

  /* ------------------------------
    4) Layout Scaffolding & Cards
    ------------------------------ */
  .app-grid{
    display:grid;
    grid-template-columns: 360px minmax(0, 1fr);
    gap:16px;
    padding:16px;
    flex-grow:1;
    overflow:hidden;
  }
  .left-panel, .right-panel{ display:flex; flex-direction:column; gap:12px; min-width:0; overflow-y:auto; overflow-x:hidden; }
  .left-panel{
    background:var(--surface-2);
    border:1px solid var(--line);
    border-radius:12px;
    padding:12px;
    box-shadow: var(--shadow);
  }
  .right-panel-content{ flex-grow:1; }

  .card{
    background:var(--surface-1);
    border:1px solid var(--line);
    border-radius:var(--radius-lg);
    box-shadow: var(--shadow);
  }
  .card-header{
    padding:10px 14px;
    border-bottom:1px solid var(--line);
    font-weight:600;
    display:flex; align-items:center; justify-content:space-between; gap:8px;
  }
  .card-content{ padding:14px; }

  @media (prefers-reduced-motion: reduce) {
    * { animation: none !important; transition: none !important; }
  }

  /* ------------------------------
    5) Editor Headings & Workbench
    ------------------------------ */
  .editor-section-title{
    text-align:left;
    font-size:1.25rem;
    font-weight:600;
    color:var(--brand-primary);
    margin: 20px 0 12px 20px; /* indented left */
    letter-spacing:.3px;
  }
  .editor-section-helper{
    margin: 0 0 16px 20px;
    font-size:.9rem;
    color:var(--muted);
    font-style:italic;
  }
  .workbench{
    background: var(--surface-1);
    border: 1px solid var(--line);
    border-radius: 16px;
    box-shadow: var(--shadow);
    padding: 16px;
    max-width: 1400px;
    margin: 0 auto;
  }

  /* Target only the mode radio buttons */
  .mode-row label {
    display: flex;              /* make label a flexbox */
    flex-direction: column;     /* stack input above text */
    align-items: center;        /* center horizontally */
    justify-content: center;    /* center vertically */
    text-align: center;         /* center the text itself */
    gap: 4px;                   /* space between input and text */
  }

  /* optional: make all labels the same width */
  .mode-row label {
    width: 100px;               /* adjust to your liking */
  }


  /* ------------------------------
    6) Stats (dashboard strip)
    ------------------------------ */
  .stats-row{
    display:flex;
    gap:20px;
    padding:10px 20px;
    background: var(--surface-1);
    border-bottom:1px solid var(--line);
  }
  .stats-row .stat{ font-weight:600; color: var(--brand-primary); }

  .stats-wrap{
    display:flex; gap:16px; padding:12px 16px;
    border-bottom:1px solid var(--line);
    background: var(--surface-3);
  }
  .stats-block, .client-stats{
    background: var(--surface-1);
    border:1px solid var(--line);
    border-radius:12px;
    padding:12px 14px;
    box-shadow: var(--shadow);
  }
  .stats-block{ flex:1 1 60%; }
  .client-stats{ flex:1 1 40%; }
  .stat-title{ font-weight:700; margin-bottom:6px; }
  .stats-pills{ display:flex; flex-wrap:wrap; gap:8px; }
  .client-stats ul{ list-style:none; margin:0; padding:0; display:grid; gap:6px; }
  .client-stats li{
    display:flex; justify-content:space-between; align-items:center;
    padding:8px 10px; border:1px solid var(--line); border-radius:10px;
    background: var(--surface-1);
  }
  .client-name{ color: var(--fg); }
  .client-count{
    font-weight:700; padding:2px 8px; border-radius:999px;
    border:1px solid var(--line); background: var(--surface-3);
  }

  /* ------------------------------
    7) Form Controls & Buttons
    ------------------------------ */
  input, select, textarea{
    width:100%; max-width:100%;
    padding:10px 12px;
    border:1px solid var(--line);
    border-radius:10px;
    background:var(--surface-1);
    color:var(--fg);
    outline:none;
    transition: box-shadow .15s, border-color .15s, background .15s;
  }
  input:focus, select:focus, textarea:focus{
    box-shadow:0 0 0 3px var(--ring);
    border-color:transparent;
  }
  textarea{ min-height:70px; }
  button{
    font-size:14px;
    padding:8px 12px;
    border-radius:10px;
    border:1px solid var(--line);
    background:var(--surface-1);
    color:var(--fg);
    cursor:pointer;
    transition: filter .12s, background .12s, border-color .12s;
    max-width:100%;
  }
  button:hover{ filter:brightness(0.98); }
  button.primary{ background:var(--accent); color:#fff; border-color:var(--accent); }
  button.danger{ border-color:var(--danger); color:var(--danger); }
  .actions button{ background:var(--cta); border-color:var(--cta); color:var(--cta-text); }
  .actions button:hover{ filter:brightness(.95); }
  body.gold-all button:not(.danger){
    background:var(--cta) !important; border-color:var(--cta) !important; color:var(--cta-text) !important;
  }
  #generateXlsx{ background:var(--brand-secondary); border-color:var(--brand-secondary); color:#1e1e1e; }
  #generateXlsx:hover{ filter:brightness(.95); }

  :focus-visible { outline: none; box-shadow: 0 0 0 3px var(--ring); border-radius: 8px; }

  /* ------------------------------
    8) Left Panel (question list)
    ------------------------------ */
  #question-list { min-width: 0; overflow-x: hidden; }
  .left-panel { flex: 0 0 360px; min-width: 0; overflow-x: hidden; }
  .left-panel > .stack > * { min-width: 0; }

  .q-item{
    padding:10px 12px; border:1px solid var(--line);
    border-radius:10px; background:var(--surface-1);
    cursor:grab; transition: border-color .12s, background .12s, box-shadow .12s;
    max-width:100%;
  }
  .q-item + .q-item{ margin-top:8px; }
  .q-item:hover{ border-color:var(--accent-weak); }
  .q-item.active{
    background:var(--surface-3);
    border-color:var(--accent-weak);
    box-shadow:0 0 0 1px var(--accent-weak) inset;
  }
  .q-item .text{ color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .q-item .summary{ font-size:12px; color:var(--muted); margin-top:4px; }
  .tag{
    background: rgba(167,181,219,.25);
    color: var(--accent-weak);
    padding:2px 8px; border-radius:999px; font-size:12px; font-weight:600;
  }

  /* ------------------------------
    9) Editor Tabs & Empty State
    ------------------------------ */
  .editor-tabs{ display:flex; gap:6px; border-bottom:1px solid var(--line); padding:0 14px; background:var(--surface-1); border-top-left-radius:12px; border-top-right-radius:12px; }
  .tab{ padding:8px 12px; border:1px solid transparent; border-bottom:0; border-radius:8px 8px 0 0; cursor:pointer; color:var(--muted); }
  .tab.active{ background:var(--surface-1); border-color:var(--line); color:var(--fg); }
  .tab-content{ display:none; }
  .tab-content.active{ display:block; }

  #editor-panel:empty::before{
    content:"Select a question from the left to edit it, or add a new one.";
    color:var(--muted);
    background:var(--surface-1);
    border:2px dashed var(--line);
    border-radius:12px;
    display:flex; align-items:center; justify-content:center;
    height:100%; text-align:center; padding:20px;
  }

  /* ------------------------------
    10) Simple Flow/Layout helpers
    ------------------------------ */
  .row{ display:grid; grid-template-columns: 140px minmax(0, 1fr); gap:10px; margin:10px 0; align-items:start; }
  .stack{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  .status-msg{ margin-left:auto; text-align:right; }
  .ok{ color:#16a34a; font-size:12px; }
  .error{
    margin:16px; white-space:pre-wrap; color:#7f1d1d;
    background:#fef2f2; border:1px solid #fecaca; padding:10px; border-radius:8px;
  }

  /* ------------------------------
    11) Dashboard grid & pills
    ------------------------------ */
  .grid{ display:grid; grid-template-columns: repeat(auto-fill, minmax(260px,1fr)); gap:12px; }
  .project-card .meta{ color:var(--muted); font-size:12px; }
  .pill{ padding:2px 8px; border:1px solid var(--line); border-radius:999px; font-size:12px; }

 /* ------------------------------
   12) Preview scaffolding
  ------------------------------ */
  .pv-wrap { padding: 16px 20px 28px; }
  .pv-header h2 { margin: 0; font-size: 20px; }
  .pv-sub { color: #666; margin-top: 2px; }

  .pv-sec { margin-top: 18px; }
  .pv-sec > h3 { margin: 12px 0 8px; font-size: 16px; }
  .pv-empty {
    padding: 10px 12px; color: #777; background:#f7f7fb;
    border:1px solid #eee; border-radius:8px;
  }

  .preset-wrap { position: relative; }

  .pv-row{
    display: grid; grid-template-columns: 90px 1fr; gap: 10px 14px;
    padding: 10px 12px; border: 1px solid #e5e8f1; border-radius: 12px; margin: 8px 0; background: #fff;
  }
  .pv-qid{ font-weight: 600; color: #212161; align-self: start; }
  .pv-body{ display:flex; flex-direction:column; gap:6px; }
  .pv-title{ font-weight: 600; }
  .pv-meta{ display:flex; flex-wrap:wrap; gap:8px 12px; align-items:center; }
  .pv-chip{
    display:inline-block; font-size:12px; padding:2px 8px; border-radius:999px;
    background:#E3EAF7; color:#335899; border:1px solid #A7B5DB;
  }

  /* Preview subtabs */
  .pv-tabs{ display:flex; gap:6px; margin:12px 0; padding-left: 6px; }
  .pv-tab{
    padding:8px 12px; border:1px solid var(--line);
    border-radius:999px; background:var(--surface-1);
    color:var(--muted); font-weight:600; cursor:pointer;
  }
  .pv-tab.active{ color:var(--fg); box-shadow:0 0 0 2px var(--ring); }
  .pv-panel{ display:none; }
  .pv-panel.active{ display:block; }
  .pv-table{ width:100%; border-collapse:collapse; margin-top:8px; }
  .pv-table th, .pv-table td{ border:1px solid #e5e8f1; padding:6px 8px; text-align:left; }
  .pv-row.banner{ border:1px dashed var(--line); }
  body.sidebar-mode .pv-tabs { display: none !important; }

  /* ------------------------------
    13) Banner preview grid
  ------------------------------ */
  .pv-banner-wrap { 
    overflow-x: auto; 
    -webkit-overflow-scrolling: touch; 
  }
  /* Container grid */
  .pv-banner-grid{
    position: relative;
    display: grid;
    grid-template-columns: repeat(var(--pv-col-n, 1), minmax(140px, 1fr));
    grid-auto-rows: auto;
  }

  .pv-banner-grid { --pv-col-min: 160px; --pv-col-add: 60px; } /* Reduced from 72px */

  /* optional visual tweaks so the small tile still looks nice */
  .pv-cell--add { padding: 8px 6px; }
  .pv-cell--add .pv-plus { transform: scale(.9); }

  /* Row wrappers (content rows only; no borders/backgrounds) */
  .pv-banner-h1,
  .pv-banner-h2,
  .pv-banner-stats{
    display: contents !important;
    background: transparent !important;
    border: 0 !important;
    grid-column: auto !important;
  }

  /* Background blocks per H1 (sit behind cells) */
  .pv-banner-block{
    z-index: 0;
    pointer-events: none;
    background: var(--pv-surface-1, #fff);
    border-top: 1px solid var(--pv-border, #d9dbe0);
    border-bottom: 1px solid var(--pv-border, #d9dbe0);
    border-radius: 8px;
  }

  /* Vertical divider between H1 blocks */
  .pv-banner-divider{
    grid-row: 1 / span 3;
    border-left: 1px solid var(--pv-border-strong, #c8cad0);
    opacity: .6;
  }

  /* Generic cell */
  .pv-banner-cell{
    position: relative;
    display: flex; align-items: center; justify-content: flex-start;
    padding: 10px 12px;
    background: var(--pv-surface, #fff);
    border: 1px solid var(--pv-border, #d9dbe0);
    border-top: none;
  }

  /* Letters row */
  .pv-banner-stats .pv-banner-cell{
    background: var(--pv-stats-bg, #fafbfe);
    font-size: 12px; color: #6b7280;
    text-align: center; justify-content: center;
    border-bottom-left-radius: 8px; border-bottom-right-radius: 8px;
  }

  /* H1 header cell */
  .pv-banner-cell.pv-h1{
    background: var(--pv-h1-bg, #f6f7fb);
    border-top: 1px solid var(--pv-border, #d9dbe0);
    border-bottom: 2px solid var(--pv-accent, #222);   /* accent underline */
    font-weight: 600;
    justify-content: space-between;
    border-top-left-radius: 8px; border-top-right-radius: 8px;
  }
  /* thin rule for other H1 borders (keeps one accent underline style) */
  .pv-banner-h1 .pv-banner-cell{ border-bottom: 1px solid var(--line) !important; }
  .pv-h1-text{ padding-right: 8px; }
  .pv-banner-h1 .pv-banner-cell,
  .pv-banner-h2 .pv-banner-cell,
  .pv-banner-stats .pv-banner-cell{ z-index: 1; }  /* ensure they sit above blocks */

  /* H2 cells */
  .pv-banner-cell.pv-h2{ min-height: 56px; }
  .pv-h2-inner{
    display: flex; align-items: center; gap: 6px; width: 100%;
  }

  /* 3-dot menu */
  .pv-menu{
    margin-left: auto;
    background: transparent; border: none; cursor: pointer;
    padding: 2px 6px; opacity: .6; border-radius: 6px;
  }
  .pv-menu:hover{ opacity:1; background: rgba(0,0,0,.04); }
  @media (hover: none){ .pv-menu{ display: inline-flex; } } /* touch friendly */

  /* Keep the H1 band continuous (no color change in the middle) */
  .pv-banner-grid .pv-add-per-h1{
    background: var(--pv-surface, #fff);
    border-top: 1px solid var(--pv-border, #d9dbe0);
    border-left-color: var(--pv-border, #d9dbe0);
  }

  /* Far-right spacer under the final H1 “+” (no borders, no bg) */
  .pv-banner-grid .pv-add-final-spacer{
    background: transparent;
    border: 0;
    min-height: 56px;        /* keep row height consistent */
    pointer-events: none;    /* no accidental clicks */
  }


  /* (Optional) ensure the background bands sit under cells */
  .pv-banner-grid .pv-banner-block{ z-index: 0; }
  .pv-banner-grid .pv-banner-h1,
  .pv-banner-grid .pv-banner-h2,
  .pv-banner-grid .pv-banner-stats{ z-index: 1; }
  
  /* Inline delete (H1 or optional H2) */
  .pv-del{
    position: absolute; right: 6px; top: 8px;
    padding: 2px 8px; border: 1px solid var(--line);
    border-radius: 8px; background: var(--surface-1);
    font-weight: 700; line-height: 1; color: var(--muted);
    cursor: pointer; display: none; z-index: 4;
  }
  .pv-banner-h1 .pv-banner-cell:hover > .pv-del,
  .pv-banner-h2 .pv-banner-cell:hover > .pv-del,
  .pv-del:focus, .pv-del:focus-visible{
    display: inline-flex; outline: none; box-shadow: 0 0 0 2px var(--ring);
    border-radius: 6px;
  }

  /* Add-cell (pill button inside; no dashed cell borders) */
  .pv-banner-cell.pv-add-cell{
    background: var(--pv-surface, #fff);
    border: 1px solid var(--pv-border, #d9dbe0);
    border-top: none;         /* match regular H2 cells */
    min-height: 56px;         /* same height as .pv-h2 */
    justify-content: center;  /* keep the + pill centered */
  }
  .pv-add-btn{ border: none; background: transparent; cursor: pointer; }
  .pv-add-pill{
    border: 1px dashed var(--line);
    background: var(--surface-1);
    opacity: .95;
  }
  .pv-add-pill:hover{ opacity: 1; }


  .pv-banner-cell.pv-h1.pv-add-cell{
    background: var(--pv-h1-bg, #f6f7fb);
    border-top: 1px solid var(--pv-border, #d9dbe0);
    border-bottom: 2px solid var(--pv-accent, #222);
  }

  .pv-banner-cell.pv-add-per-h1 {
    grid-row: span 2;      /* Span H2 and Stats rows */
    align-items: center;   /* Vertically center the '+' */
  }

  /* Make the final H1 '+' look like a single column and match H1 styling */
  .pv-add-h1-final{
    background: var(--pv-h1-bg, #f6f7fb);
    border-top: 1px solid var(--pv-border, #d9dbe0);
    border-bottom: 2px solid var(--pv-accent, #222);
    justify-content: center;
    grid-row: span 3;      /* Span all 3 header rows */
    height: 100%;            /* Fill the vertical space */
    align-items: center;     /* Vertically center the '+' button */
  }


  /* Inline editor */
  .pv-editable{ cursor: text; border-radius: 6px; padding: 2px 4px; }
  .pv-editable:focus-within{ box-shadow: 0 0 0 2px var(--ring); outline: none; }
  .pv-inline-input{
    width: 100%; font: inherit; padding: 4px 6px;
    border: 1px solid var(--pv-border, #d9dbe0); border-radius: 6px; background: #fff;
  }

  /* Condition dot */
  .pv-cond-dot{
    position: absolute; right: 8px; bottom: 8px;
    width: 8px; height: 8px; border-radius: 50%;
    background: var(--pv-accent, #222); opacity: 0;
  }
  .pv-banner-cell.has-cond .pv-cond-dot{ opacity: .9; }

  /* Cell action menu (popover) */
  .pv-cell-menu{
    position: fixed; z-index: 1001; min-width: 220px;
    background: var(--surface-1); border: 1px solid var(--line);
    border-radius: 10px; box-shadow: var(--shadow); padding: 6px;
  }
  .pv-cell-menu .mitem{ display:block; width:100%; text-align:left; padding:8px 10px; border-radius:8px; }
  .pv-cell-menu .mitem:hover{ background: var(--surface-3); }
  .pv-cell-menu .subhead{ font-size:12px; color: var(--muted); padding:6px 10px 2px; }

  /* Helpers & legacy */
  .muted{ color: #6b7280; }
  .pv-col-del, .pv-dim-del{ display: none !important; }

  /* Toast */
  .toast{
    display: inline-flex; align-items: center; gap: 10px;
    padding: 10px 12px; border: 1px solid var(--line);
    border-radius: 12px; background: var(--surface-1); box-shadow: var(--shadow);
    max-width: min(520px, 92vw);
  }
  .toast button{ padding: 6px 10px; border-radius: 10px; }
  #toastHost{ pointer-events: none; }
  #toastHost .toast{ pointer-events: auto; }



  /* ------------------------------
    14) Modal (centered)
    ------------------------------ */
  .modal { position: fixed; inset: 0; z-index: 1000; display: grid; place-items: center; }
  .modal-panel{
    width: min(720px, 92vw);
    background: var(--surface-1);
    border: 1px solid var(--line);
    border-radius: 16px;
    box-shadow: var(--shadow);
    overflow: hidden;
    transform: translateY(-6px);
    animation: modalIn .18s ease-out;
  }
  @keyframes modalIn{ from {opacity:0; transform: translateY(-16px);} to {opacity:1; transform: translateY(0);} }
  .modal-header{
    display:flex; align-items:center; justify-content:space-between;
    padding:16px 20px;
    background: var(--surface-2);
    border-bottom: 1px solid var(--line);
  }
  .modal-body{
    padding: 16px 20px; display: grid; gap: 12px;
  }
  .modal-footer{
    display:flex; justify-content:flex-end; gap:10px;
    padding: 12px 20px 16px;
    background: var(--surface-2);
    border-top: 1px solid var(--line);
  }
  .modal-backdrop{
    background: rgba(0,0,0,.35);
    backdrop-filter: blur(2px);
  }

  /* =======================================================
   NEW: Sidebar Navigation Styles
   ======================================================= */
   #app-sidebar {
    position: fixed;
    top: 0;
    left: 0;
    height: 100%;
    width: 260px;
    background: var(--surface-2);
    border-right: 1px solid var(--line);
    padding: 16px;
    z-index: 100;
    transform: translateX(-100%); /* Hidden by default */
    transition: transform 0.3s ease-out;
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  body.sidebar-open #app-sidebar {
    transform: translateX(0); /* Show sidebar */
  }

  /* Sidebar links - vertical layout */
  #app-sidebar .nav-btn {
    display: flex;
    justify-content: flex-start;
    width: 100%;
    border-radius: var(--radius-md);
    padding: 12px 16px;
  }

  /* Backdrop to dim/blur content */
  .sidebar-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.1);
    backdrop-filter: blur(2px);
    z-index: 99;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease-out;
  }

  body.sidebar-open .sidebar-backdrop {
    opacity: 1;
    pointer-events: auto;
  }

  /* Make sure header toggle button is visible */
  #sidebar-toggle {
      display: inline-flex;
  }

  /* ===== Slide-out Side Drawer ===== */
  .side-drawer{
    position: fixed;
    left: 0; top: 64px;           /* adjust top to your header height */
    height: calc(100vh - 64px);
    z-index: 1000;
    display: flex;
    align-items: flex-start;
    pointer-events: none;         /* let children control interaction */
  }

  /* Hamburger handle */
  .sd-handle{
    pointer-events: auto;
    width: 44px; height: 44px;
    margin: 8px 0 0 8px;
    border: 1px solid #e1e4ea;
    background: #fff;
    border-radius: 10px;
    box-shadow: 0 2px 8px rgba(0,0,0,.08);
    display: grid; place-items: center;
    cursor: pointer;
  }
  .sd-handle span{
    display:block; width:18px; height:2px; background:#333; margin:3px 0; border-radius:2px;
  }
  .side-drawer.pinned .sd-handle{ border-color: var(--brand-primary, #212161); }

  /* Slide-out panel */
  .sd-panel{
    pointer-events: auto;
    width: 260px; max-width: 80vw;
    margin-top: 8px; margin-left: 8px;
    background: var(--panel-bg, #fff);
    border: 1px solid #e1e4ea;
    border-radius: 14px;
    box-shadow: 0 10px 30px rgba(0,0,0,.12);
    transform: translateX(-16px) translateX(-100%);  /* fully hidden */
    transition: transform .22s ease-out;
    padding: 10px;
  }

  /* Open on hover, or when pinned */
  .side-drawer:hover .sd-panel,
  .side-drawer.pinned .sd-panel{
    transform: translateX(0);
  }

  /* Inside nav */

  .sd-title {
    margin: 8px 8px 4px;       /* more top margin above section titles */
  }
  .sd-link {
    padding: 12px 14px;        /* was 10px 12px */
    margin: 2px 0;             /* add a little vertical gap */
    border-radius: 10px;
  }
  .sd-link:hover{ background: rgba(33,33,97,.06); }
  .sd-link.pv-tab.active{
    background: rgba(33,33,97,.10);
    color: var(--brand-primary);
    font-weight:600;
  }

  .sd-panel hr{ border:0; border-top:1px solid var(--line); margin:8px 0; }

  /* Mobile: keep it tappable and not in the way */
  @media (max-width: 900px){
    .side-drawer{ top: 56px; height: calc(100vh - 56px); }
    .sd-handle{ width:40px; height:40px; }
    .sd-panel{ width: 80vw; }
  }

  /* Hide the little floating handle (we already have a header hamburger) */
  .sd-handle{ display:none !important; }

  /* Turn the slide-out into a dropdown panel under the header button */
  .side-drawer{
    position: fixed;
    inset: 0;            /* we’ll position the panel via JS; backdrop lives here */
    pointer-events: none;
    z-index: 1000;
  }
  .side-drawer .sd-panel{
    position: absolute;
    transform: none !important;    /* disable slide transform */
    width: 280px;
    max-height: min(70vh, 560px);
    overflow: auto;
    background: var(--surface-1);
    border: 1px solid var(--line);
    border-radius: 14px;
    box-shadow: var(--shadow);
    pointer-events: auto;
    display: none;                  /* hidden by default */
    padding: 10px;
  }

  /* Show when body has the open class */
  body.sidebar-open .side-drawer .sd-panel{ display:block; }

  /* Backdrop for clicks outside */
  .sidebar-backdrop{ backdrop-filter: blur(2px); }

  .sd-link .icon {
    margin-right: 8px;
    flex-shrink: 0;
  }

  .select-row .select-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    gap: 4px;
    min-width: 80px;  /* adjust as needed */
  }

  .option-row .chk { display:inline-flex; align-items:center; gap:6px; }


</style>
<body>
  <header>
    <div class="project-inputs">
      <button id="sidebar-toggle" title="Toggle Sidebar" class="icon-btn">☰</button>
      <input id="projName" placeholder="Project Name" title="Project Name" />
      <input id="projClient" placeholder="Client" title="Client" />
      <input id="projVersion" placeholder="Version" title="Version" />
    </div>

    <div class="logo">
      <img src="icons/logo.png" alt="Your Company Name" height="48" />
    </div>

    <div class="actions">
      <label class="muted" for="themeSwitch">Theme</label>
      <select id="themeSwitch" title="Theme">
        <option value="cue-light">Cue Light</option>
        <option value="cue-dark">Cue Dark</option>
        <option value="cue-gold">Cue Gold</option>
      </select>
      <button id="importJson" class="cta">📥 Import</button>
      <button id="downloadJson" class="cta">💾 Export</button>
      <button id="generateDocx" class="cta">📝 QRE</button>
      <button id="generateXlsx" class="cta">⚙️ Tab Plan</button>
      <div id="status" class="status-msg"></div>
    </div>
  </header>

  <!-- Slide-out navigation (hamburger) -->
  <div id="sideDrawer" class="side-drawer">
    <button id="sdHandle" class="sd-handle" title="Open menu" aria-label="Open menu">
      <span></span><span></span><span></span>
    </button>
    <div class="sd-panel" role="menu" aria-label="Main navigation">
      <div class="sd-title">Navigate</div>

      <button class="sd-link pv-tab" data-route="#/dashboard">
        <!-- Home icon -->
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"
            fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round"
            class="icon">
          <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
          <polyline points="9 22 9 12 15 12 15 22"/>
        </svg>
        Dashboard
      </button>

      <button class="sd-link pv-tab" data-route="#/editor">
        <!-- Edit icon -->
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"
            fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round"
            class="icon">
          <path d="M12 20h9"/>
          <path d="M16.5 3.5a2.121 2.121 0 1 1 3 3L7 19l-4 1 1-4z"/>
        </svg>
        Editor
      </button>

      <button class="sd-link pv-tab" data-route="#/library">
        <!-- Book icon -->
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"
            fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round"
            class="icon">
          <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"/>
          <path d="M4 4.5A2.5 2.5 0 0 1 6.5 7H20"/>
          <path d="M20 22V2a2 2 0 0 0-2-2H6.5A2.5 2.5 0 0 0 4 2.5v19z"/>
        </svg>
        Library
      </button>

      <button class="sd-link pv-tab" data-route="#/rules">
        <!-- List icon -->
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"
            fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round"
            class="icon">
          <line x1="8" y1="6" x2="21" y2="6"/>
          <line x1="8" y1="12" x2="21" y2="12"/>
          <line x1="8" y1="18" x2="21" y2="18"/>
          <line x1="3" y1="6" x2="3" y2="6"/>
          <line x1="3" y1="12" x2="3" y2="12"/>
          <line x1="3" y1="18" x2="3" y2="18"/>
        </svg>
        Rules
      </button>

      <button class="sd-link pv-tab" data-route="#/validator">
        <!-- Check-square icon -->
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"
            fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round"
            class="icon">
          <path d="M9 11l3 3L22 4"/>
          <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"/>
        </svg>
        Validator
      </button>

      <button class="sd-link pv-tab" data-route="#/versions">
        <!-- Archive icon -->
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16"
            fill="none" stroke="currentColor" stroke-width="2"
            stroke-linecap="round" stroke-linejoin="round"
            class="icon">
          <rect x="3" y="4" width="18" height="4" rx="1"/>
          <path d="M21 8v13a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8"/>
          <line x1="12" y1="12" x2="12" y2="17"/>
        </svg>
        Versions
      </button>


      <hr />
      <div class="sd-edv-head">
        <div class="sd-title">Editor Views</div>
        <select id="sdProjectSel" title="Active project">
          <!-- options injected by JS -->
        </select>
      </div>

      <button class="sd-link" data-goto="#/editor/pre">Pre-Field</button>
      <button class="sd-link" data-goto="#/editor/field">Fielding</button>
      <button class="sd-link" data-goto="#/editor/report">Reporting</button>
      <button class="sd-link" data-goto="#/editor/post">Post-Survey</button>
    </div>
  </div>

  <!-- Backdrop (click to close) -->
  <div class="sidebar-backdrop" id="sidebarBackdrop"></div>


  <div id="editor-subtabs" class="subtabs is-hidden">
    <div class="subtabs-inner">
      <button data-subtab="pre"     onclick="goto('#/editor/pre')"     class="subtab">Pre-Field</button>
      <button data-subtab="field"   onclick="goto('#/editor/field')"   class="subtab">Fielding</button>
      <button data-subtab="report"  onclick="goto('#/editor/report')"  class="subtab">Reporting</button>
      <button data-subtab="post"    onclick="goto('#/editor/post')"    class="subtab">Post-Survey</button>
    </div>
  </div>


  <div id="createProjectModal" class="modal is-hidden" role="dialog" aria-modal="true" aria-labelledby="cp-title">
  <div class="modal-panel" onclick="event.stopPropagation()">
    <div class="modal-header">
      <h3 id="cp-title">Create Project</h3>
      <button class="icon-btn" onclick="closeCreateProjectModal()" aria-label="Close">✕</button>
    </div>

    <div class="modal-body">
      <label class="field">
        <span>Project Name</span>
        <input id="cp-name" type="text" placeholder="e.g., INFUSE Claims Test" />
      </label>

      <label class="field">
        <span>Client</span>
        <input id="cp-client" type="text" placeholder="e.g., Kenvue / JJIV" />
      </label>

      <label class="field">
        <span>Important Dates (free text)</span>
        <input id="cp-dates" type="text" placeholder="e.g., Field: Sep 12–16; Report: Sep 20" />
      </label>

      <label class="field">
        <span>Notes</span>
        <textarea id="cp-notes" rows="4" placeholder="Any context, constraints, deliverables…"></textarea>
      </label>
    </div>

    <div class="modal-footer">
      <button class="btn ghost" onclick="closeCreateProjectModal()">Cancel</button>
      <button class="btn primary" onclick="createProjectFromModal()">Create Project</button>
    </div>
  </div>
  <div class="modal-backdrop" onclick="closeCreateProjectModal()"></div>
</div>

  <main id="view-root" style="flex:1; overflow:auto"></main>

  <div id="serverError" class="error" style="display:none; margin:12px"></div>

<script>
/* --- guard: nuke any legacy globals if a stale file injected them --- */
for (const k of ["ensureRules","renderEditorPanel","renderRules","renderEditor","renderPreview","renderDashboard"]) {
  try { delete window[k]; } catch {}
}

/* =========================
   LIKERT PRESET CATALOG
   ========================= */
const LIKERT_PRESETS = {
  agreement: {
    label: "Agreement",
    byPoints: {
      3: ["Disagree","Neither","Agree"],
      5: ["Strongly disagree","Disagree","Neither","Agree","Strongly agree"],
      7: ["Strongly disagree","Disagree","Somewhat disagree","Neither","Somewhat agree","Agree","Strongly agree"],
      10: ["1","2","3","4","5","6","7","8","9","10"]
    }
  },
  applicability: {
    label: "Applicability",
    byPoints: {
      3: ["Not applicable","Somewhat applicable","Fully applicable"],
      5: ["Not at all applicable","Slightly applicable","Moderately applicable","Very applicable","Extremely applicable"],
      7: ["Not at all","Slightly","Somewhat","Moderately","Very","Highly","Extremely"],
      10: ["1","2","3","4","5","6","7","8","9","10"]
    }
  },
  consideration: {
    label: "Consideration",
    byPoints: {
      3: ["Would not consider","Might consider","Would consider"],
      5: ["Definitely would not","Probably would not","Might or might not","Probably would","Definitely would"],
      7: ["Definitely not","Probably not","Somewhat not","Unsure","Somewhat would","Probably would","Definitely would"],
      10: ["1","2","3","4","5","6","7","8","9","10"]
    }
  },
  likelihood: {
    label: "Likelihood",
    byPoints: {
      3: ["Unlikely","Neither","Likely"],
      5: ["Very unlikely","Unlikely","Neither","Likely","Very likely"],
      7: ["Extremely unlikely","Very unlikely","Unlikely","Neither","Likely","Very likely","Extremely likely"],
      10:["Not at all likely","2","3","4","5","6","7","8","9","Extremely likely"]
    }
  },
  satisfaction: {
    label: "Satisfaction",
    byPoints: {
      3: ["Dissatisfied","Neutral","Satisfied"],
      5: ["Very dissatisfied","Dissatisfied","Neutral","Satisfied","Very satisfied"],
      7: ["Extremely dissatisfied","Very dissatisfied","Dissatisfied","Neutral","Satisfied","Very satisfied","Extremely satisfied"],
      10:["1","2","3","4","5","6","7","8","9","10"]
    }
  }
};

/* Build the mini UI for picking a preset (renders inside a host div) */
  function openPresetPicker(i){
  const host = document.getElementById(`presetHost-${i}`);
  if (!host) return;

  // Toggle open/close
  if (host.style.display === 'block') { host.style.display = 'none'; host.innerHTML = ''; return; }
  host.style.display = 'block';

  const close = () => {
    host.style.display = 'none';
    host.innerHTML = '';
    document.removeEventListener('click', onDocClick, true);
    document.removeEventListener('keydown', onEsc, true);
  };
  const onDocClick = (e) => {
    if (!host.contains(e.target) && e.target.id !== `presetBtn-${i}`) close();
  };
  const onEsc = (e) => { if (e.key === 'Escape') close(); };

  document.addEventListener('click', onDocClick, true);
  document.addEventListener('keydown', onEsc, true);

  const ptsOptions = [3,5,7,10].map(n=>`<option value="${n}">${n} pt.</option>`).join("");
  const typeOptions = Object.entries(LIKERT_PRESETS)
    .map(([k,v])=>`<option value="${k}">${v.label}</option>`).join("");

  host.innerHTML = `
    <div class="sticky-head">
      <div class="stack" style="align-items:flex-end; flex-wrap:wrap;">
        <label>Points
          <select id="prePts-${i}" style="min-width:120px">${ptsOptions}</select>
        </label>
        <label>Scale type
          <select id="preType-${i}" style="min-width:220px">${typeOptions}</select>
        </label>
        <button id="preApply-${i}" class="primary">Apply</button>
        <button id="preCancel-${i}">Cancel</button>
        <button id="preCustom-${i}">Create your own...</button>
      </div>
    </div>
    <div class="muted">Preview:</div>
    <div id="prePrev-${i}" class="mono" style="white-space:normal; word-break:break-word;"></div>
  `;

  const $pts  = document.getElementById(`prePts-${i}`);
  const $type = document.getElementById(`preType-${i}`);
  const $prev = document.getElementById(`prePrev-${i}`);

  function refreshPreview(){
    const t   = $type.value;
    const pts = parseInt($pts.value, 10);
    const labels = (LIKERT_PRESETS[t]?.byPoints?.[pts]) || [];
    $prev.textContent = labels.join(" | ");
  }
  $pts.onchange = refreshPreview;
  $type.onchange = refreshPreview;
  refreshPreview();

  document.getElementById(`preCancel-${i}`).onclick = close;

  // "Create your own…" is now correctly wired here
  document.getElementById(`preCustom-${i}`).onclick = () => {
    openPresetMaker(i);
  };

  document.getElementById(`preApply-${i}`).onclick = () => {
    const q   = state.questions[i];
    const t   = $type.value;
    const pts = parseInt($pts.value, 10);
    const labels = (LIKERT_PRESETS[t]?.byPoints?.[pts]) || [];
    if (!labels.length) return close();

    // Ensure table mode & sync
    q.mode = 'table';
    q.grid ||= { rows: q.statements || [], cols: [] };
    q.grid.cols = [...labels];
    q.scale ||= {};
    q.scale.labels = [...labels];
    q.scale.points = labels.length;

    harmonizeTypeFromMode(q);
    syncTableFacets(q);
    queueAutosave();
    renderEditorPanel();
    setStatus(`Applied ${pts}-pt ${LIKERT_PRESETS[t].label} preset.`, true);
    close();
  };

  // Keep the panel within viewport horizontally (simple edge guard)
  const rect = host.getBoundingClientRect();
  const overflowRight = rect.right - (window.innerWidth - 12);
  if (overflowRight > 0) host.style.left = `calc(0px - ${overflowRight}px)`;
}

/************* THEME *************/
const THEME_KEY = "qgen_theme";
const themeSel = document.getElementById("themeSwitch");
function applyThemeName(name){
  document.documentElement.setAttribute("data-theme", name);
  document.body.classList.toggle("gold-all", name === "cue-gold");
  localStorage.setItem(THEME_KEY, name);
  themeSel.value = name;
}
(function initTheme(){ const saved = localStorage.getItem(THEME_KEY) || "cue-light"; applyThemeName(saved); themeSel.addEventListener("change", e => applyThemeName(e.target.value)); })();

/************* STATE *************/
const AUTOSAVE_KEY = "qgen_autosave_v3";
const PROJECTS_KEY = "qgen_projects_v1"; // dashboard store
const LIB_KEY = "qgen_library_v1";      // question library
const SNAP_KEY = "qgen_snapshots_v1";   // versions per project (by id)

const $  = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));

/* ========= PRESET SCALES (built-in + custom storage) ========= */
const PRESET_KEY = "qgen_custom_scales_v1"; // localStorage

// Built-ins. Keep "Numerical" first; others alphabetical in UI.
const BUILTIN_SCALES = {
  3: {
    Numerical: ["1","2","3"],
    Agreement: ["Strongly disagree","Disagree","Strongly agree"],
    Frequency: ["Rarely","Sometimes","Often"],
  },
  5: {
    Numerical: ["1","2","3","4","5"],
    Agreement: ["Strongly disagree","Disagree","Neutral","Agree","Strongly agree"],
    Consideration: ["Definitely would not consider","Probably would not consider","Might or might not consider","Probably would consider","Definitely would consider"],
    Application: ["Not at all applicable","Slightly applicable","Moderately applicable","Very applicable","Extremely applicable"],
  },
  7: {
    Numerical: ["1","2","3","4","5","6","7"],
    Agreement: ["Strongly disagree","Disagree","Somewhat disagree","Neutral","Somewhat agree","Agree","Strongly agree"],
  },
  10: {
    Numerical: ["1","2","3","4","5","6","7","8","9","10"],
  }
};

function loadCustomScales(){
  try { return JSON.parse(localStorage.getItem(PRESET_KEY) || "{}"); }
  catch { return {}; }
}
function saveCustomScales(map){
  localStorage.setItem(PRESET_KEY, JSON.stringify(map));
}
function getScalesFor(points){
  const built = BUILTIN_SCALES[points] || {};
  const customMap = loadCustomScales();
  const custom = (customMap[points] || {});    // {Name: [labels]}
  // Order: Numerical first (if present), then others alpha
  const names = Object.keys({...built, ...custom});
  const numericalFirst = names.sort((a,b)=>{
    if (a==="Numerical") return -1;
    if (b==="Numerical") return 1;
    return a.localeCompare(b);
  });
  return numericalFirst.map(name => ({
    name,
    labels: (custom[name] || built[name])
  }));
}
function saveCustomPreset(points, name, labels, description=""){
  const map = loadCustomScales();
  (map[points] ||= {});
  map[points][name] = labels;
  // (Optional) you could also store descriptions in a sibling map if wanted
  saveCustomScales(map);
}


const state = {
  project: { id: "proj-" + Math.random().toString(16).slice(2,10), name:"", client:"", version:"0.1.0", created_at:new Date().toISOString(), updated_at:new Date().toISOString(), notes:"" },
  globals: {
    default_base_verbiage: "Total (qualified respondents)",
    default_base_definition: "",
    default_banners: [],
    scale_buckets: {
      "5pt":{"TB":[5],"T2B":[4,5],"B2B":[1,2],"BB":[1],"Mean":true},
      "7pt":{"TB":[7],"T2B":[6,7],"B2B":[1,2],"BB":[1],"Mean":true},
      "10pt":{"TB":[10],"T2B":[9,10],"B2B":[1,2],"BB":[1],"Mean":true}
    }
  },
  questions: []
};
const ui_state = { active_question_index: null, active_tab: 'main', route: location.hash || '#/dashboard', active_prefield_tab: 'screener' };
ui_state.base_builders = ui_state.base_builders || {};
state.globals.banners = state.globals.banners || [{
  id: "BNR_CORE",
  label: "Core Demo & Cohorts",
  mode: "concat",
  dimensions: []
}]; 

/* ===== STEP 1: Option/Question defaults + migration ===== */
const OPTION_DEFAULTS = {
  exclusive: false,        // already existed
  terminate: false,        // already existed
  anchor: null,            // 'top' | 'bottom' | null
  lock_randomize: false,   // keep position even if shuffled
  custom_code: "",         // export-only override
  custom_label: ""         // export-only override
};

const QUESTION_DEFAULTS = {
  randomization: {         // question-level randomization controls
    mode: "none",          // 'none' | 'shuffle'
    seed: null             // optional reproducibility
  }
};

function migrateQuestionModel(q){
  if (!q || typeof q !== "object") return q;

  // Ensure options exist and carry new flags
  if (Array.isArray(q.options)) {
    q.options = q.options.map((o, i) => ({
      // ensure basic shape
      code:  o?.code  ?? String(i + 1),
      label: o?.label ?? String(o?.text ?? o?.value ?? ""),
      // apply new defaults, then overlay existing props (so old data wins)
      ...OPTION_DEFAULTS,
      ...o
    }));
  }

  // Add/merge question-level randomization
  q.randomization = { ...QUESTION_DEFAULTS.randomization, ...(q.randomization || {}) };

  return q;
}

function migrateProjectModel(){
  state.questions = (state.questions || []).map(migrateQuestionModel);
}

migrateProjectModel();

function refreshSidebarProjects(){
  const sel = document.getElementById('sdProjectSel');
  if (!sel) return;

  const list = getProjects(); // reads localStorage
  if (!list.length){
    sel.innerHTML = '<option value="">No projects</option>';
    sel.disabled = true;
    return;
  }

  sel.disabled = false;
  sel.innerHTML = list.map(p =>
    `<option value="${p.id}" ${p.id === state.project?.id ? 'selected' : ''}>
       ${escapeHTML(p.name || 'Untitled')}
     </option>`
  ).join('');

  sel.onchange = (e)=> openProjectById(e.target.value);
}

/************* ROUTER (robust) *************/
const routes = new Map();

function mount(viewEl, html){
  viewEl.innerHTML = html;
  // activate any [data-action] buttons here if needed later
}

function highlightNav(){
  const r = location.hash || '#/dashboard';
  document.querySelectorAll('.nav-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.route === r);
  });
}

// bind clicks on nav buttons
document.querySelectorAll('.nav-btn').forEach(btn => {
  btn.addEventListener('click', () => { location.hash = btn.dataset.route; });
});

// go live
window.addEventListener('hashchange', renderRoute);
window.addEventListener('DOMContentLoaded', renderRoute);

/************* UTIL *************/
function setStatus(msg, ok){ const el = $("#status"); el.innerHTML = msg? `<span class="${ok?'ok':''}">${msg}</span>`: ""; }
function escapeHTML(s){ return String(s||'').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;', "'":'&#39;'}[m])); }
function goto(hash){ location.hash = hash; }
function getCoreBanner() {
  const g = state.globals;
  if (!g.banners?.length) g.banners = [{ id:"BNR_CORE", label:"Core Demo & Cohorts", mode:"concat", dimensions:[] }];
  return g.banners[0];
}
function findQuestionById(qid){ return state.questions.find(q => (q.id||"").toUpperCase() === (qid||"").toUpperCase()); }

// ===== Hamburger toggle & sidebar links =====
(function(){
  const body = document.body;
  const toggleBtn = document.getElementById('sidebar-toggle'); // existing button in header
  const drawer    = document.getElementById('sideDrawer');
  const handle    = document.getElementById('sdHandle');
  const backdrop  = document.getElementById('sidebarBackdrop');

  function openSidebar(){ body.classList.add('sidebar-open'); }
  function closeSidebar(){ body.classList.remove('sidebar-open'); }
  function toggleSidebar(){ body.classList.toggle('sidebar-open'); }

  toggleBtn?.addEventListener('click', (e)=>{ e.preventDefault(); toggleSidebar(); });
  handle?.addEventListener('click', (e)=>{ e.preventDefault(); drawer.classList.toggle('pinned'); openSidebar(); });
  backdrop?.addEventListener('click', closeSidebar);

  // Delegate clicks inside the drawer
  drawer?.addEventListener('click', (e) => {
    const btn = e.target.closest('.sd-link');
    if (!btn) return;

    const gotoHash = btn.getAttribute('data-goto');
    const route    = btn.getAttribute('data-route');

    if (gotoHash) { location.hash = gotoHash; }
    if (route)    { location.hash = route; }

    // close after navigating (unless pinned)
    if (!drawer.classList.contains('pinned')) closeSidebar();
  });

  // Extend your existing highlight function so it marks the sidebar too
  const _origHighlight = typeof highlightNav === 'function' ? highlightNav : null;
  window.highlightNav = function(){
    const r = location.hash || '#/dashboard';
    // Keep old behavior for any top-nav buttons left in DOM
    document.querySelectorAll('.nav-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.route === r);
    });
    // Sidebar active state
    document.querySelectorAll('.sd-link.pv-tab[data-route]').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.route === r);
    });
  };

  // Run once on load
  highlightNav();
})();

// ===== PHASE 1: Tab Plan data model & nets core =====

// Ensure the per-question Tab bucket exists
function ensureTabBucket(q){
  if (!q) return null;
  if (!q.tab || typeof q.tab !== 'object'){
    q.tab = { nets: [], instructions: "" };
  }else{
    q.tab.nets = Array.isArray(q.tab.nets) ? q.tab.nets : [];
    q.tab.instructions = typeof q.tab.instructions === "string" ? q.tab.instructions : "";
  }
  return q.tab;
}

// Quick type helpers (used by UI later)
function isNumericQuestion(q){ return String(q?.type||"").toLowerCase().startsWith("numeric"); }
function isCodesQuestion(q){
  // single/multi/list/table/likert/open-ends → anything with options/cols/scale labels
  if (Array.isArray(q?.options) && q.options.length) return true;
  if (Array.isArray(q?.grid?.cols) && q.grid.cols.length) return true;
  if (Array.isArray(q?.scale?.labels) && q.scale.labels.length) return true;
  return false;
}

// Constructors (normalized)
function createCodesNet({ label=null, codes=[] }){
  const uniq = Array.from(new Set((codes||[]).map(c => String(c))));
  return { kind: "codes", label: label ? String(label) : null, codes: uniq };
}
function createRangeNet({ min, max }){
  const mn = Number(min), mx = Number(max);
  return { kind: "range", min: mn, max: mx };
}

// Keep all nets valid & current against the live question definition
function syncNetsWithQuestion(q){
  const tab = ensureTabBucket(q);
  if (!tab) return null;

  // For codes-nets, drop codes that no longer exist; for ranges, coerce & validate.
  tab.nets = (tab.nets||[]).map(net => {
    if (net?.kind === "codes"){
      const labelOf = (code)=>getOptionLabel(q.id, code);  // already in your file
      const kept = (net.codes||[]).map(String).filter(c => !!labelOf(c));
      if (!kept.length) return null;
      return { kind:"codes", label: (net.label||null), codes: Array.from(new Set(kept)) };
    }
    if (net?.kind === "range") {
        // First, check for the new structure created by the modal
        if (net.operator) {
            const v1 = Number(net.value1);
            // The first value must always be a valid number
            if (!Number.isFinite(v1)) {
                return null;
            }
            // If it's a range ('-'), the second value must also be valid
            if (net.operator === '-') {
                const v2 = Number(net.value2);
                if (!Number.isFinite(v2) || v1 > v2) {
                    return null; // A range requires a valid v2, and v1 must be <= v2
                }
            }
            return net; // The net is valid, so we keep it
        }

        // Fallback for the old structure (min/max)
        const mn = Number(net.min), mx = Number(net.max);
        if (Number.isFinite(mn) && Number.isFinite(mx) && mn <= mx) {
            return { kind: "range", min: mn, max: mx };
        }
        
        return null; // The net is invalid in any format
    }
    return null; // unknown kinds are dropped
  }).filter(Boolean);

  return tab;
}

// Handy global: sync every question at once (use before painting UI or exporting)
function syncAllNets(){
  (state.questions||[]).forEach(syncNetsWithQuestion);
}

// (Optional) Safe constructors exposed for later UI
window.QTab = { ensureTabBucket, createCodesNet, createRangeNet, syncNetsWithQuestion, syncAllNets };

function ensureDimensionFromQuestion(qid) {
  const q = findQuestionById(qid);
  if (!q) return null;
  const bnr = getCoreBanner();

  // 1) normal single/multi questions
  let srcLabels = [];
  let srcCodes  = [];

  if (Array.isArray(q.options) && q.options.length) {
    srcLabels = q.options.map(o => String(o.label ?? ''));
    srcCodes  = q.options.map((o, i) => String(o.code ?? (i + 1)));
  }
  // 2) table/likert: grid columns
  else if (Array.isArray(q.grid?.cols) && q.grid.cols.length) {
    srcLabels = q.grid.cols.map(c => String(c ?? ''));
    srcCodes  = srcLabels.map((_, i) => String(i + 1));
  }
  // 3) simple likert (single/dual) with scale labels
  else if (Array.isArray(q.scale?.labels) && q.scale.labels.length) {
    srcLabels = q.scale.labels.map(l => String(l ?? ''));
    srcCodes  = srcLabels.map((_, i) => String(i + 1));
  }

  // 4) numeric questions
  else if (isNumericQuestion(q)) {
    const opts = getQuestionOptions(q); // uses q.tab.nets / nets_text if present
    if (!opts.length) return null;
    srcLabels = opts.map(o => String(o.label ?? ''));
    srcCodes  = opts.map(o => String(o.code));
  }

  // if still nothing, there’s nothing to render
  if (!srcCodes.length) return null;

  // Generate a unique dim id each time this question is added
  const instanceCount = (bnr.dimensions || []).filter(d => d?.source?.qid === q.id).length + 1;
  const dimId = `DIM_${q.id}__${Date.now()}_${instanceCount}`;

  const groups = srcCodes.map((code, i) => ({
    // Make group ids unique by namespacing with the dim id
    group_id: `${dimId}:${code}`,
    ref: { qid: q.id, opt_id: String(code) },
    label_alias: null,
    include: true,
    order: i + 1
  }));

  const dim = {
    dim_id: dimId,
    source: { type: "question", qid: q.id },
    label: q.text || q.id,
    order: (bnr.dimensions.length + 1),
    groups
  };

  bnr.dimensions.push(dim);
  queueAutosave?.();
  return dim;
}

function updateDimAlias(dim_id, alias){
  const d = getCoreBanner().dimensions.find(x => x.dim_id === dim_id);
  if (!d) return;
  if (alias == null || String(alias).trim() === '') {
    d.label = getDimDefaultLabel(d);   // ← now resolves to question text
  } else {
    d.label = String(alias);
  }
  queueAutosave?.();
}
function getDimDefaultLabel(dim){
  const qid = dim?.source?.qid;
  const q   = findQuestionById(qid);
  // fallback order: question text → QID → empty
  return (q?.text?.trim() || qid || '').trim();
}
function toggleGroupInclude(group_id, on){ const d = getCoreBanner().dimensions; for (const dim of d){ const g = dim.groups.find(x => x.group_id === group_id); if (g){ g.include = !!on; queueAutosave?.(); return; } } }
function setGroupAlias(group_id, alias){ const d = getCoreBanner().dimensions; for (const dim of d){ const g = dim.groups.find(x => x.group_id === group_id); if (g){ g.label_alias = (alias||"").trim() || null; queueAutosave?.(); return; } } }
function reorderGroups(dim_id, newOrder){ const d = getCoreBanner().dimensions.find(x => x.dim_id === dim_id); if (!d) return; d.groups = newOrder.map((gid, i) => ({...d.groups.find(g=>g.group_id===gid), order:i+1})); queueAutosave?.(); }
function reorderDimensions(newDimIds){ const b = getCoreBanner(); b.dimensions = newDimIds.map((id,i)=>({...b.dimensions.find(d=>d.dim_id===id), order:i+1})); queueAutosave?.(); }
function removeBannerColumn(dim_id, group_id){
  const b = getCoreBanner();
  const d = b.dimensions.find(x => x.dim_id === dim_id);
  if (!d) return;
  const g = d.groups.find(x => x.group_id === group_id);
  if (!g) return;
  // soft delete: hide from preview/exports but keep editable history
  g.include = false;
  queueAutosave?.();
}
/* ===== Delete banner header 1 ===== */
function removeBannerDimension(dim_id, {soft=true} = {}){
  const b = getCoreBanner();
  const idx = b.dimensions.findIndex(d => d.dim_id === dim_id);
  if (idx < 0) return;

  if (soft) {
    // keep the dimension object but hide all groups
    b.dimensions[idx].groups?.forEach(g => g.include = false);
  } else {
    // hard delete the entire dimension
    b.dimensions.splice(idx, 1);
  }
  // re-number order so future inserts look tidy
  b.dimensions.forEach((d, i) => d.order = i + 1);
  queueAutosave?.();
}
function getOptionLabel(qid, code){
  const q = findQuestionById(qid);
  if (!q) return null;

  // prefer explicit options
  const byOpt = (q.options || []).find(o => String(o.code ?? '') === String(code ?? ''));
  if (byOpt) return byOpt.label ?? null;

  // grid columns (tables / likerts)
  const idx = Number(code) - 1;
  if (Array.isArray(q.grid?.cols) && q.grid.cols[idx]) return q.grid.cols[idx];

  // fallback to scale labels (single/dual likert)
  if (Array.isArray(q.scale?.labels) && q.scale.labels[idx]) return q.scale.labels[idx];

  return null;
}

function ensureGroupCond(g){
  if (!g.cond) g.cond = { all: [], any: [] };
  if (!Array.isArray(g.cond.all)) g.cond.all = [];
  if (!Array.isArray(g.cond.any)) g.cond.any = [];
  return g.cond;
}

function dedupeCond(g){
  ensureGroupCond(g);
  const key = c => `${c.qid}::${String((c.codes||[]).sort())}`;
  const uniq = arr => {
    const seen = new Set(); const out = [];
    for (const c of arr){ const k=key(c); if(!seen.has(k)){ seen.add(k); out.push(c); } }
    return out;
  };
  g.cond.all = uniq(g.cond.all||[]);
  g.cond.any = uniq(g.cond.any||[]);
}


function hasCond(g){
  return !!(g?.cond && (g.cond.all?.length || g.cond.any?.length));
}

function condSummary(g){
  if (!hasCond(g)) return '';

  const formatClause = (c) => {
    if (c.type === 'numeric') {
      if (c.op === 'between') return `${c.qid} is ${c.op} ${c.values[0]} and ${c.values[1]}`;
      return `${c.qid} ${c.op} ${c.values[0]}`;
    }
    // Fallback for original categorical clauses
    return `${c.qid} in [${(c.codes||[]).join(',')}]`;
  };

  const allClauses = (g.cond.all || []).map(formatClause);
  const anyClauses = (g.cond.any || []).map(formatClause);

  let summary = '';
  if (allClauses.length) summary += `AND: ( ${allClauses.join(' AND ')} )`;
  if (anyClauses.length) summary += ` OR: ( ${anyClauses.join(' OR ')} )`;

  return summary.trim();
}


function parseNumericBands(q){
  const txt = q?.exports?.tab_plan?.nets_text || '';
  // Accept things like "Net: 1-5, 6-10, 11-15, 16-24"
  const bands = Array.from(txt.matchAll(/(\d+)\s*-\s*(\d+)/g))
    .map(m => ({ code: `${m[1]}-${m[2]}`, label: `${m[1]}–${m[2]}` }));
  return bands;
}

/** Get selectable options for a question, returning [{code,label}] */
function getQuestionOptions(q){
  if (!q) return [];
  if (Array.isArray(q.options) && q.options.length){
    return q.options.map((o,i)=>({ code:String(o.code ?? (i+1)), label:String(o.label ?? '') }));
  }
  if (Array.isArray(q.grid?.cols) && q.grid.cols.length){
    return q.grid.cols.map((lab,i)=>({ code:String(i+1), label:String(lab ?? '') }));
  }
  if (Array.isArray(q.scale?.labels) && q.scale.labels.length){
    return q.scale.labels.map((lab,i)=>({ code:String(i+1), label:String(lab ?? '') }));
  }

  // ✅ NEW: numeric nets from q.tab.nets (primary)
  if (isNumericQuestion(q) && Array.isArray(q.tab?.nets) && q.tab.nets.length){
    const bands = q.tab.nets
      .map(n => {
        // operator style (new editor)
        if (n.operator) {
          const v1 = Number(n.value1), v2 = Number(n.value2);
          const mk = (lab, code) => ({ code:String(code), label:String(lab) });

          switch (n.operator) {
            case '-': if (Number.isFinite(v1) && Number.isFinite(v2) && v1 <= v2)
                        return mk(n.label || `${v1}–${v2}`, `${v1}-${v2}`);
                      break;
            case 'exact': if (Number.isFinite(v1)) return mk(n.label || `${v1}`, `==${v1}`); break;
            case '+': if (Number.isFinite(v1)) return mk(n.label || `${v1}+`, `>=${v1}`); break;
            case '<': if (Number.isFinite(v1)) return mk(n.label || `<${v1}`, `<${v1}`); break;
            case '>': if (Number.isFinite(v1)) return mk(n.label || `>${v1}`, `>${v1}`); break;
            case '<=': if (Number.isFinite(v1)) return mk(n.label || `≤${v1}`, `<=${v1}`); break;
            case '>=': if (Number.isFinite(v1)) return mk(n.label || `≥${v1}`, `>=${v1}`); break;
          }
          return null;
        }
        // legacy range {min,max}
        if (Number.isFinite(n.min) && Number.isFinite(n.max) && n.min <= n.max){
          return { code: `${n.min}-${n.max}`, label: n.label || `${n.min}–${n.max}` };
        }
        return null;
      })
      .filter(Boolean);
    if (bands.length) return bands;
  }

  // Fallback: parse from exports.tab_plan.nets_text (existing behavior)
  if ((q.type||'').startsWith('numeric')) {
    const bands = parseNumericBands(q);  // e.g. ["1-5","6-10",...]
    if (bands.length) return bands;      // already returns {code,label}
  }

  return [];
}

// Returns the options array in the correct display order for preview/runtime,
// based on per-question randomization settings.
function randomizedOptions(q){
  const opts = Array.isArray(q?.options) ? q.options.slice() : [];
  const mode = q?.randomization?.mode || 'none';
  if (mode !== 'shuffle' || opts.length < 2) return opts;

  // --- Fisher–Yates (stable) ---
  for (let i = opts.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [opts[i], opts[j]] = [opts[j], opts[i]];
  }
  return opts;
}

/* ===== Sync banner with questions ===== */
function syncBannerWithQuestions({prune=true, addNew=false} = {}) {
  const b = getCoreBanner();
  const dims = b.dimensions || [];
  for (const d of dims) {
    if (!d?.source?.qid) continue;
    const q = findQuestionById(d.source.qid);
    if (!q) {
      // question gone → drop whole dimension
      if (prune) b.dimensions = dims.filter(x => x !== d);
      continue;
    }
    const liveCodes = new Set(getQuestionOptions(q).map(o => String(o.code ?? '')));
    // remove groups whose option no longer exists
    d.groups = (d.groups||[]).filter(g => liveCodes.has(String(g.ref?.opt_id ?? '')));
    // optionally add any newly added options as visible columns
    if (addNew) {
      for (const opt of (q.options||[])) {
        const code = String(opt.code ?? '');
        if (!d.groups.find(g => String(g.ref?.opt_id ?? '') === code)) {
          d.groups.push({
            group_id: `${q.id}:${code}`,
            ref: { qid: q.id, opt_id: code },
            label_alias: null,
            include: true,
            order: (d.groups.length + 1)
          });
        }
      }
    }
    // re-order numbers
    d.groups.forEach((g,i)=> g.order = i+1);
  }
  // tidy dimension order
  b.dimensions?.forEach((d,i)=> d.order = i+1);
}

// ==========================================================
// Banner Cell Menu Helpers (Global Scope)
// ==========================================================
let _openMenuEl = null;

function closeCellMenu() {
  if (_openMenuEl) {
    _openMenuEl.remove();
    _openMenuEl = null;
  }
  document.removeEventListener('pointerdown', onAway, true);
}

function onAway(e) {
  if (_openMenuEl && !e.composedPath().includes(_openMenuEl)) {
    closeCellMenu();
  }
}

function openCellMenu(anchor, dimId, groupId) {
  // Close any existing menu first
  try { closeCellMenu?.(); } catch {}

  const grid = document.getElementById('pvBannerGrid');
  if (!grid) return;

  // Resolve a robust anchor: prefer the .pv-menu button for positioning
  const btn = (anchor && anchor.closest) 
    ? anchor.closest('.pv-menu') 
    : null;
  if (!btn) return;

  // Build the menu
  const menu = document.createElement('div');
  menu.className = 'pv-cell-menu';
  menu.innerHTML = `
    <button class="mitem" data-act="edit-text">Edit text</button>
    <button class="mitem" data-act="duplicate">Duplicate column</button>
    <div class="subhead">Add condition</div>
    <button class="mitem" data-act="add-and">ADD criteria (AND)</button>
    <button class="mitem" data-act="add-or">OR criteria</button>
    <button class="mitem" data-act="edit-eqn">Create/Edit equation</button>
    <button class="mitem" data-act="delete">Delete</button>
  `;
  document.body.appendChild(menu);
  window._openMenuEl = menu; // keep your global if you rely on it elsewhere

  // Position (assumes .pv-cell-menu is position: fixed)
  const r = btn.getBoundingClientRect();
  const pad = 8;
  // Measure after attach so offsetWidth is valid
  const mw = menu.offsetWidth || 220;
  let left = Math.max(pad, r.left);
  left = Math.min(window.innerWidth - pad - mw, left);
  const top = r.bottom + 6;

  menu.style.left = left + 'px';
  menu.style.top  = top + 'px';

  // Helper: close and clean up the listener
  const safeClose = () => {
    document.removeEventListener('pointerdown', onAway, true);
    if (window._openMenuEl === menu) window._openMenuEl = null;
    menu.remove();
  };

  // Close when clicking away (but ignore clicks on the button or inside the menu)
  const onAway = (e) => {
    if (menu.contains(e.target) || btn.contains(e.target)) return;
    safeClose();
  };
  document.addEventListener('pointerdown', onAway, true);

  // Menu actions
  menu.addEventListener('click', (e) => {
    const item = e.target.closest('.mitem');
    if (!item) return;

    const act  = item.dataset.act;
    const host = document.getElementById('prefield-content-host');

    if (act === 'edit-text') {
      const cellEl = grid.querySelector(`.pv-banner-cell[data-g="${groupId}"] .pv-editable`);
      if (cellEl) cellEl.dispatchEvent(new Event('dblclick', { bubbles: true }));
    }

    else if (act === 'duplicate') {
      const banner = getCoreBanner();
      const dim = banner?.dimensions?.find(d => d.dim_id === dimId);
      const idx = dim?.groups?.findIndex(g => g.group_id === groupId);
      if (dim && idx > -1) {
        const original = dim.groups[idx];
        const copy = JSON.parse(JSON.stringify(original));
        // Ensure a unique id
        copy.group_id = `${groupId}_copy_${Date.now()}`;
        // Friendly label
        const baseLab = copy.label_alias || getOptionLabel(dim.source?.qid, copy.ref?.opt_id) || 'Copy';
        copy.label_alias = `${baseLab} (Copy)`;
        // Insert next to original
        dim.groups.splice(idx + 1, 0, copy);
        // Re-number order
        dim.groups.forEach((g, i) => g.order = i + 1);
        setStatus?.('Column duplicated.', true);
        renderPreviewBanner?.(host);
      }
    }

    else if (act === 'add-and') {
      openCondWizard?.('AND', dimId, groupId);
    }

    else if (act === 'add-or') {
      openCondWizard?.('OR', dimId, groupId);
    }

    else if (act === 'edit-eqn') {
      openCondEditor?.(dimId, groupId);
    }

    else if (act === 'delete') {
      const dim = getCoreBanner()?.dimensions?.find(d => d.dim_id === dimId);
      const g = dim?.groups?.find(x => x.group_id === groupId);
      if (g && confirm('Remove this banner column from the preview?')) {
        removeBannerColumn?.(dimId, groupId);
        setStatus?.('Column removed.', true);
        renderPreviewBanner?.(host);
      }
    }

    safeClose();
  });

  // Keyboard niceties
  menu.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') safeClose();
  });
  // Focus first actionable item for accessibility
  menu.querySelector('.mitem')?.focus();
}

let _toastTimer = null;
function showToast(message, actionLabel, onAction, duration=5000){
  const host = document.getElementById('toastHost');
  if (!host) return;
  host.innerHTML = `
    <div class="toast">
      <span>${message}</span>
      ${actionLabel ? `<button class="btn" id="toastAction">${actionLabel}</button>` : ``}
      <button class="btn ghost" id="toastClose">Close</button>
    </div>`;
  clearTimeout(_toastTimer);
  if (actionLabel) {
    document.getElementById('toastAction')?.addEventListener('click', ()=>{
      host.innerHTML = '';
      try { onAction && onAction(); } catch {}
    });
  }
  document.getElementById('toastClose')?.addEventListener('click', ()=> host.innerHTML = '');
  _toastTimer = setTimeout(()=> host.innerHTML = '', duration);
}

function startInlineEdit({container, initial, onCommit, onCancel}) {
  if (!container) return;

  container.classList.add('pv-editing');
  const origHTML = container.innerHTML;
  container.innerHTML = `
    <input type="text" value="${escapeHTML(initial)}" />
    <button class="pv-edit-btn">Save</button>
    <button class="pv-reset-btn">Cancel</button>
  `;
  const input = container.querySelector('input');
  const btnSave = container.querySelector('.pv-edit-btn');
  const btnCancel = container.querySelector('.pv-reset-btn');

  let committed = false, canceled = false;

  input.focus(); input.select();

  function cleanup(revert){
    container.classList.remove('pv-editing');
    if (revert) container.innerHTML = origHTML;
    document.removeEventListener('pointerdown', onDocDown, true);
  }
  function commit(){
    if (committed || canceled) return;
    committed = true;
    onCommit?.(input.value.trim());
    cleanup(false);
  }
  function cancel(){
    if (committed || canceled) return;
    canceled = true;
    onCancel?.();
    cleanup(true);
  }

  // Save/Cancel buttons
  btnSave?.addEventListener('click', commit);
  btnCancel?.addEventListener('click', cancel);

  // Keyboard: Enter=save, Esc=cancel
  input.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter') commit();
    if (e.key === 'Escape') cancel();
  });

  // CLICK-AWAY = SAVE
  // If the next pointerdown is outside the editing container, commit.
  function onDocDown(e){
    // Ignore clicks inside the edit UI (input / buttons)
    if (container.contains(e.target)) return;
    commit();
  }
  document.addEventListener('pointerdown', onDocDown, true);

  // Also catch simple blur (e.g., tabbing away)
  input.addEventListener('blur', () => {
    // If focus moves to Save/Cancel, don't auto-commit here; buttons will handle it.
    const to = document.activeElement;
    if (to === btnSave || to === btnCancel) return;
    // Slight defer so button click handlers can run first if applicable
    setTimeout(()=> commit(), 0);
  });
}
// clear alias (back to original name)
function resetGroupAlias(group_id){
  const dims = getCoreBanner().dimensions || [];
  for (const d of dims){
    const g = d.groups?.find(x => x.group_id === group_id);
    if (g){ g.label_alias = null; queueAutosave?.(); return; }
  }
}
function resetDimAlias(dim_id){
  const d = getCoreBanner().dimensions?.find(x => x.dim_id === dim_id);
  if (d){ d.label = d.label; /* no-op; alias is the label itself for dims */ }
}

function openAddColumnWizard(dimId /* null => add a new H1 */){
  const banner = getCoreBanner();
  const dims   = banner.dimensions || [];
  const dim    = dimId ? dims.find(d => d.dim_id === dimId) : null;
  const lockedQid = dim?.source?.qid || null; // when adding under an existing H1

  // Build question dropdown
  const qOpts = state.questions.map(q =>
    `<option value="${q.id}">${escapeHTML(q.id)} — ${escapeHTML(q.text||'')}</option>`
  ).join('');

  // Modal
  const overlay = document.createElement('div');
  overlay.className = 'modal';
  overlay.innerHTML = `
    <div class="modal-panel" onclick="event.stopPropagation()">
      <div class="modal-header">
        <h3>Add banner ${dim ? 'column' : 'category & column'}</h3>
        <button class="icon-btn" id="acClose">✕</button>
      </div>
      <div class="modal-body">
        ${dim ? `
          <div class="muted">Target category (H1): <b>${escapeHTML(dim.label || dim.source?.qid || '')}</b></div>
        ` : `
          <label>
            <span>New H1 label (optional)</span>
            <input id="acH1Label" placeholder="e.g., Custom Segment" />
          </label>
        `}

        <label style="margin-top:8px;">
          <span>Base question</span>
          ${lockedQid
            ? `<div class="muted"><b>${escapeHTML(lockedQid)}</b> (locked to this category)</div>`
            : `<select id="acQ"><option value="">Select question…</option>${qOpts}</select>`
          }
        </label>

        <div id="acOpts" class="stack" style="flex-wrap:wrap; gap:8px; margin-top:12px;"></div>

        <div id="acNumCustom" style="display:none; margin-top:12px; border-top:1px solid var(--line); padding-top:12px;">
          <div class="subhead">Custom numeric band (optional)</div>
          <div class="stack" style="gap:8px; align-items:center;">
            <select id="acNumOp" style="width:150px;">
              <option value="between">is between</option>
              <option value="==">is equal to</option>
              <option value=">=">&ge; (greater or equal)</option>
              <option value="<=">&le; (less or equal)</option>
              <option value=">">&gt; (greater than)</option>
              <option value="<">&lt; (less than)</option>
            </select>
            <input type="number" id="acNumV1" placeholder="Value 1" style="width:120px;" />
            <span id="acNumAnd">and</span>
            <input type="number" id="acNumV2" placeholder="Value 2" style="width:120px;" />
            <input type="text" id="acNumLabel" placeholder="Band label (optional)" style="width:180px;" />
          </div>
        </div>

        <label class="stack" style="margin-top:12px; align-items:center;">
          <input type="checkbox" id="acOpenCond" checked />
          <span>Open condition builder after adding</span>
        </label>
      </div>
      <div class="modal-footer">
        <button class="btn" id="acCancel">Cancel</button>
        <button class="btn primary" id="acSave">Add</button>
      </div>
    </div>
    <div class="modal-backdrop"></div>
  `;
  document.body.appendChild(overlay);
  const close = ()=> overlay.remove();
  overlay.querySelector('#acClose').onclick = close;
  overlay.querySelector('#acCancel').onclick = close;

  const $qSel = overlay.querySelector('#acQ');
  const $opts = overlay.querySelector('#acOpts');
  const $numBox = overlay.querySelector('#acNumCustom');
  const $opSel = overlay.querySelector('#acNumOp');
  const $v1 = overlay.querySelector('#acNumV1');
  const $v2 = overlay.querySelector('#acNumV2');
  const $and = overlay.querySelector('#acNumAnd');

  function drawOptions(){
    const qid = lockedQid || ($qSel?.value || '');
    const q = findQuestionById(qid);
    if (!q) { $opts.innerHTML = `<div class="muted">Pick a question.</div>`; $numBox.style.display='none'; return; }

    // Existing option/band choices
    const opts = getQuestionOptions(q); // includes numeric nets if present
    $opts.innerHTML = opts.length
      ? opts.map(o => `
          <label class="pill">
            <input type="checkbox" class="ac-opt" value="${escapeHTML(o.code)}" />
            ${escapeHTML(o.label)} <span class="muted">(${escapeHTML(o.code)})</span>
          </label>`).join('')
      : `<div class="muted">No selectable options for this question.</div>`;

    // Numeric custom band UI
    const numeric = typeof isNumericQuestion === 'function' && isNumericQuestion(q);
    $numBox.style.display = numeric ? 'block' : 'none';
    if (numeric) {
      const setBetween = () => {
        const show2 = ($opSel.value === 'between');
        $and.style.display = show2 ? 'inline' : 'none';
        $v2.style.display  = show2 ? 'inline-block' : 'none';
      };
      $opSel.onchange = setBetween; setBetween();
    }
  }

  if ($qSel) { $qSel.onchange = drawOptions; }
  drawOptions();

  overlay.querySelector('#acSave').onclick = ()=>{
    const qid = lockedQid || ($qSel?.value || '');
    const q = findQuestionById(qid);
    if (!q) { alert('Pick a question.'); return; }

    // Which codes did they check?
    const codes = Array.from(overlay.querySelectorAll('.ac-opt:checked')).map(cb => cb.value);

    // If numeric and they filled a custom band, add it to q.tab.nets and include its code too
    if (typeof isNumericQuestion === 'function' && isNumericQuestion(q)) {
      const op = $opSel.value;
      const v1 = $v1.value.trim();
      const v2 = $v2?.value?.trim() || '';
      const lab = overlay.querySelector('#acNumLabel').value.trim();

      const needsV2 = (op === 'between');
      if (v1 !== '' && (!needsV2 || v2 !== '')) {
        // Normalize & persist band into q.tab.nets so it "stays numeric"
        q.tab ||= {}; q.tab.nets ||= [];

        let code = '';
        let netObj = { operator: '-', value1: Number(v1), value2: Number(v2), label: lab || `${v1}–${v2}` };
        if (op === 'between') {
          code = `${Number(v1)}-${Number(v2)}`;
        } else {
          const map = { '>=':'>=', '<=':'<=', '>':'>', '<':'<', '==':'exact' };
          const opKey = map[op] || 'exact';
          netObj = { operator: opKey, value1: Number(v1), value2: (opKey === 'exact' ? null : null), label: lab || (opKey==='exact' ? `${v1}` : `${op}${v1}`) };
          code = (op === '==') ? `==${Number(v1)}` : `${op}${Number(v1)}`;
        }

        q.tab.nets.push(netObj);
        // Re-sync any derived structures the rest of your code expects
        try { syncNetsWithQuestion?.(q); } catch {}
        // Make sure the new code appears in options if none were checked
        if (!codes.includes(code)) codes.push(code);
      }
    }

    if (!codes.length) { alert('Select at least one option/band or add a custom numeric band.'); return; }

    // Create or reuse the target H1
    let targetDim = dim;
    if (!targetDim) {
      const newId = `DIM_${Date.now().toString(36)}_${Math.random().toString(36).slice(2,7)}`;
      const label = (overlay.querySelector('#acH1Label')?.value.trim() || qid || 'Custom');
      targetDim = {
        dim_id: newId,
        label,                 // inline editable later
        source: { qid },       // keep tied to the question (safe with sync)
        groups: [],
        order: (dims.length + 1)
      };
      banner.dimensions.push(targetDim);
    }

    // Insert groups
    const baseOrder = targetDim.groups.length;
    const addedGroupIds = [];
    codes.forEach((code, idx) => {
      const gid = `${targetDim.dim_id}:${String(code)}:${Math.random().toString(36).slice(2,6)}`;
      const group = {
        group_id: gid,
        ref: { qid, opt_id: String(code) },
        label_alias: null,      // you can rename inline later
        include: true,
        order: baseOrder + idx + 1
      };
      targetDim.groups.push(group);
      addedGroupIds.push(gid);
    });

    // Save & redraw
    try { queueAutosave?.(); } catch {}
    const host = document.getElementById('prefield-content-host');
    renderPreviewBanner(host);

    // Optionally open the condition builder on the first new group
    const alsoCond = overlay.querySelector('#acOpenCond')?.checked;
    close();
    if (alsoCond && addedGroupIds.length) {
      openCondWizard('AND', targetDim.dim_id, addedGroupIds[0]);
    }
  };
}

/* ===== NEW: Tab Sheet summary panel (basic for now) ===== */
function renderPreviewTabSheet(host){
  const totalQs = state.questions.length;
  const likert = state.questions.filter(q =>
    (q.type||'').toLowerCase().startsWith('likert') ||
    (q.grid?.rows?.length && q.grid?.cols?.length)
  ).length;

  host.innerHTML = `
    <div class="card">
      <div class="card-header">
        <strong>Tab Sheet Summary</strong>
      </div>
      <div class="card-content">
        <table class="pv-table">
          <tr><th>Total questions</th><td>${totalQs}</td></tr>
          <tr><th>Matrix / Likert questions</th><td>${likert}</td></tr>
          <tr><th>Default base</th><td>${escapeHTML(state.globals?.default_base_verbiage || 'Total (qualified respondents)')}</td></tr>
        </table>
        <div class="pv-empty" style="margin-top:12px;">Final Excel headers will be built from the Banner Plan tab.</div>
      </div>
    </div>`;
}

function renderPreviewBanner(host) {
  // 1) normalize & sync
  if (typeof syncAllNets === "function") syncAllNets();
  syncBannerWithQuestions?.({ prune: true, addNew: false });

  const banner = getCoreBanner() || { dimensions: [] };
  const dims = (banner.dimensions || []).slice().sort((a, b) => (a.order || 0) - (b.order || 0));

  // utils
  const esc = (s) => String(s ?? "");
  const colTag = (idx) => { let n = idx + 1, s = ""; while (n > 0) { n--; s = String.fromCharCode(65 + (n % 26)) + s; n = Math.floor(n / 26); } return s; };
  const getVisGroups = (d) => (d.groups || []).filter(g => g.include !== false).sort((a, b) => (a.order || 0) - (b.order || 0));

  // "Add category" select
  const addableQs = (state.questions || []).filter(q => (getQuestionOptions(q) || []).length > 0);
  const dd = addableQs.map(q => `<option value="${esc(q.id)}">${esc(q.id)} — ${esc(q.text || "")}</option>`).join("");

  // 2) Build layout: groups + per-H1 add are inside each H1 block; then a final H1-add column
  const layout = { colSlots: [], blockSpans: [], h1: [] }; // colSlots drives grid width
  {
    let cur = 1; // grid line pointer (1-based)
    for (const d of dims) {
      const vis = getVisGroups(d);
      if (!vis.length) continue;

      // H1 spans groups + its per-H1 "+"
      layout.h1.push({ dimId: d.dim_id, text: d.label || d.source?.qid || "", span: vis.length + 1 });

      const start = cur;
      // push group slots
      for (const g of vis) layout.colSlots.push({ type: "group", dim: d, g }), cur++;
      // per-H1 "+" slot
      layout.colSlots.push({ type: "add-per-h1", dim: d }); cur++;

      const end = cur - 1; // inclusive
      layout.blockSpans.push({ start, end, dimId: d.dim_id });
    }
    // final H1-level "+" at far right
    layout.colSlots.push({ type: "add-h1-final" });
  }
  const totalCols = layout.colSlots.length;

  // 3) A..Z letters (only increment letter for real data columns)
  let letterIdx = 0;
  const statsRowHTML = layout.colSlots.map(slot => {
    if (slot.type === "group") {
        return `<div class="pv-banner-cell">${colTag(letterIdx++)}</div>`;
    }
  }).join("");


  // 4) H1 row: each header spans its groups + its per-H1 add; then a final H1 "+" column
  const h1RowHTML =
    layout.h1.map(h => `
      <div class="pv-banner-cell pv-h1" style="grid-column: span ${h.span};" title="${esc(h.text)}">
        <span class="pv-h1-text pv-editable" data-edit-type="dim" data-dimid="${h.dimId}">${esc(h.text)}</span>
        <button class="pv-del" data-dimid="${h.dimId}" title="Remove category ‘${esc(h.text)}’">✕</button>
      </div>
    `).join("") +
    `
      <div class="pv-banner-cell pv-add-cell pv-add-h1-final" title="Add a new category (H1)">
        <button class="pv-add-btn" data-act="add-h1" aria-label="Add H1">
          <span class="pv-add-pill">＋</span>
        </button>
      </div>`;

  // 5) H2 row: groups → per-H1 "+"; final column is just an empty spacer (H1 plus lives above)
  let h2RowHTML = "";
  for (const d of dims) {
    const vis = getVisGroups(d);
    if (!vis.length) continue;

    for (const g of vis) {
      const code = g.ref?.opt_id;
      const lab  = g.label_alias || getOptionLabel(d.source?.qid, code) || (code ?? g.group_id);
      const has  = (typeof hasCond === "function") ? !!hasCond(g) : false;
      const csum = (typeof condSummary === "function") ? condSummary(g) : "";
      const showCode = code && String(code) !== String(lab);

      h2RowHTML += `
        <div class="pv-banner-cell pv-h2 ${has ? 'has-cond' : ''}"
             data-dim="${d.dim_id}" data-g="${g.group_id}" title="${esc(lab)}">
          <div class="pv-h2-inner">
            <span class="pv-editable" data-edit-type="group" data-gid="${g.group_id}">
              ${esc(lab)}${showCode ? ` <small class="muted">(${esc(String(code))})</small>` : ``}
            </span>
            <button class="pv-menu" data-gid="${g.group_id}" data-dimid="${d.dim_id}" title="More options">⋯</button>
          </div>
          <span class="pv-cond-dot" title="${esc(csum)}"></span>
        </div>
      `;
    }

    // per-H1 "+" (adds a column under THIS H1)
    h2RowHTML += `
      <div class="pv-banner-cell pv-add-cell pv-add-per-h1 pv-cell--add" title="Add column to this category">
        <button class="pv-add-pill pv-add-btn" data-act="add-col" data-dimid="${d.dim_id}" aria-label="Add column">＋</button>
      </div>
    `;
  }

  // 6) Background H1 blocks + vertical dividers (dividers now sit immediately after each block)
  const blocksHTML = layout.blockSpans.map((s, i, arr) =>
    `<div class="pv-banner-block ${i===0?'is-first':''} ${i===arr.length-1?'is-last':''}"
          style="grid-column:${s.start} / ${s.end + 1};"></div>`
  ).join("");

  // MODIFICATION: The divider is now gone.
  const dividersHTML = '';

  // 7) Paint
  host.innerHTML = `
    <section class="pv-sec">
      <h3>Banner Plan Builder</h3>
      <div class="pv-banner-controls">
        <label>+ Add category
          <select id="banAddSel" ${addableQs.length ? "" : "disabled"}>
            <option value="">Select question…</option>${dd}
          </select>
        </label>
        <button id="banAddBtn" ${addableQs.length ? "" : "disabled"}>Add</button>
      </div>

      <div class="pv-banner-wrap">
        <div class="pv-banner-grid" id="pvBannerGrid">
          ${blocksHTML}
          ${dividersHTML}
          <div class="pv-banner-h1">${h1RowHTML}</div>
          <div class="pv-banner-h2">${h2RowHTML}</div>
          <div class="pv-banner-stats">${statsRowHTML}</div>
        </div>
      </div>

      ${layout.blockSpans.length ? "" : `<div class="pv-empty" style="margin-top:10px;">No banner categories yet. Add one from a question above.</div>`}
    </section>
  `;

  // 8) Grid width
  const grid = document.getElementById("pvBannerGrid");
  if (grid) grid.style.setProperty("--pv-col-n", String(totalCols || 1));
  if (grid) {
    grid.style.gridTemplateColumns = layout.colSlots
    .map(slot =>
      (slot.type === 'group' || slot.type === 'add-h1-final')
        ? 'minmax(var(--pv-col-min,160px),1fr)'
        : 'var(--pv-col-add,72px)'
    )
    .join(' ');
  }

  // 9) top “Add” controls
  const sel = document.getElementById("banAddSel");
  const addBtn = document.getElementById("banAddBtn");
  addBtn?.addEventListener("click", () => {
    const qid = sel?.value || "";
    if (!qid) return;
    ensureDimensionFromQuestion?.(qid);
    renderPreviewBanner(host);
  });

  // 10) delegates
  grid?.addEventListener("click", (e) => {
    const delBtn  = e.target.closest(".pv-del");
    const menuBtn = e.target.closest(".pv-menu");
    const plusBtn = e.target.closest(".pv-add-btn");

    if (delBtn) {
      const dimId = delBtn.dataset?.dimid;
      if (dimId && typeof removeBannerDimension === "function") {
        removeBannerDimension(dimId, { soft: false });
        renderPreviewBanner(host);
      }
      return;
    }

    if (menuBtn) {
      const dimId   = menuBtn.dataset?.dimid;
      const groupId = menuBtn.dataset?.gid;
      if (typeof openCellMenu === "function") openCellMenu(menuBtn, dimId, groupId);
      return;
    }

    if (plusBtn) {
      const act   = plusBtn.dataset?.act;
      const dimId = plusBtn.dataset?.dimid || null;
      if (act === "add-col") {
        if (typeof openAddColumnWizard === "function") openAddColumnWizard(dimId);
      } else if (act === "add-h1") {
        if (typeof openAddColumnWizard === "function") openAddColumnWizard(null);
        else {
          document.getElementById("banAddSel")?.focus();
        }
      }
    }
  });

  // 11) inline edit (H1 & H2 labels)
  grid?.addEventListener("dblclick", (e) => {
    const editable = e.target.closest(".pv-editable");
    if (!editable) return;

    const startInlineEdit = ({ container, initial, onCommit }) => {
      if (!container || container.classList.contains("pv-editing")) return;
      container.classList.add("pv-editing");
      const orig = container.innerHTML;
      container.innerHTML = `<input class="pv-inline-input" type="text" value="${esc(initial)}" />`;
      const input = container.querySelector("input");
      input.focus(); input.select();

      const commit = () => onCommit?.(input.value.trim());
      input.addEventListener("blur", commit);
      input.addEventListener("keydown", (evt) => {
        if (evt.key === "Enter") commit();
        if (evt.key === "Escape") { container.innerHTML = orig; container.classList.remove("pv-editing"); }
      });
    };

    const type = editable.dataset.editType;
    if (type === "group") {
      const cell = editable.closest(".pv-banner-cell");
      const dimId = cell.dataset.dim;
      const groupId = cell.dataset.g;
      const d = getCoreBanner().dimensions.find(d => d.dim_id === dimId);
      const g = d?.groups.find(x => x.group_id === groupId);
      if (!g) return;

      const code = g.ref?.opt_id;
      const current = g.label_alias || getOptionLabel(d.source?.qid, code) || "";
      startInlineEdit({
        container: editable,
        initial: current,
        onCommit: (txt) => { setGroupAlias(groupId, txt || null); renderPreviewBanner(host); }
      });
    } else if (type === "dim") {
      const dimId = editable.dataset.dimid;
      const d = getCoreBanner().dimensions.find(x => x.dim_id === dimId);
      if (!d) return;
      const current = d.label || d.source?.qid || "";
      startInlineEdit({
        container: editable,
        initial: current,
        onCommit: (txt) => { updateDimAlias(dimId, txt || null); renderPreviewBanner(host); }
      });
    }
  });
}



function openCondWizard(kind /* 'AND' | 'OR' */, dimId, groupId){
  const banner = getCoreBanner();
  const dim = banner.dimensions.find(d => d.dim_id === dimId);
  const g = dim?.groups.find(x => x.group_id === groupId);
  if (!g) return;
  ensureGroupCond(g);

  // Build question list (use anything already in the project)
  const qOpts = state.questions.map(q => `<option value="${q.id}">${escapeHTML(q.id)} — ${escapeHTML(q.text||'')}</option>`).join('');

  const overlay = document.createElement('div');
  overlay.className = 'modal';
  overlay.innerHTML = `
    <div class="modal-panel" onclick="event.stopPropagation()">
      <div class="modal-header">
        <h3>${kind === 'AND' ? 'Add AND criteria' : 'Add OR criteria'}</h3>
        <button class="icon-btn" id="cwClose">✕</button>
      </div>
      <div class="modal-body">
        <label>Pick a question
          <select id="cwQ">${qOpts}</select>
        </label>
        <div id="cwOpts" class="stack" style="flex-wrap:wrap; gap:8px; margin-top: 12px;"></div>
      </div>
      <div class="modal-footer">
        <button class="btn" id="cwCancel">Cancel</button>
        <button class="btn primary" id="cwSave">Add</button>
      </div>
    </div>
    <div class="modal-backdrop"></div>`;

  function close(){ overlay.remove(); }
  overlay.querySelector('#cwClose').onclick = close;
  overlay.querySelector('#cwCancel').onclick = close;
  document.body.appendChild(overlay);

  const $q = overlay.querySelector('#cwQ');
  const $box = overlay.querySelector('#cwOpts');

  function drawOpts(){
    const q = findQuestionById($q.value);

    // ==========================================================
    // NEW: Check if the question is numeric and show a new UI
    // ==========================================================
    if (isNumericQuestion(q)) {
      $box.innerHTML = `
        <div class="stack" style="gap: 8px; align-items: center;">
          <select id="cwNumOp" style="width: 150px;">
            <option value="between">is between</option>
            <option value="==">is equal to</option>
            <option value=">=">&gt;= (greater or equal)</option>
            <option value="<=">&lt;= (less or equal)</option>
            <option value=">">&gt; (greater than)</option>
            <option value="<">&lt; (less than)</option>
          </select>
          <input type="number" id="cwNumVal1" placeholder="Value 1" style="width: 120px;" />
          <span id="cwNumAnd" style="display: inline;">and</span>
          <input type="number" id="cwNumVal2" placeholder="Value 2" style="width: 120px;" />
        </div>
      `;
      // Add a listener to hide the second input if not needed
      const opSelect = document.getElementById('cwNumOp');
      opSelect.onchange = () => {
        const showSecond = opSelect.value === 'between';
        document.getElementById('cwNumAnd').style.display = showSecond ? 'inline' : 'none';
        document.getElementById('cwNumVal2').style.display = showSecond ? 'inline-block' : 'none';
      };
      opSelect.onchange(); // Trigger once to set initial state
      return;
    }
    // ==========================================================
    // END NEW
    // ==========================================================


    const opts = getQuestionOptions(q);
    $box.innerHTML = opts.length
      ? opts.map(o => `
          <label class="pill">
            <input type="checkbox" value="${escapeHTML(o.code)}" />
            ${escapeHTML(o.label)} <span class="muted">(${escapeHTML(o.code)})</span>
          </label>`).join('')
      : `<div class="muted">This question has no selectable options.</div>`;
  }
  $q.onchange = drawOpts; drawOpts();

  overlay.querySelector('#cwSave').onclick = ()=>{
    const qid = $q.value;
    const q = findQuestionById(qid);
    let clause = null;

    // ==========================================================
    // MODIFIED: Construct the correct clause object
    // ==========================================================
    if (isNumericQuestion(q)) {
      const op = document.getElementById('cwNumOp').value;
      const val1 = document.getElementById('cwNumVal1').value;
      const val2 = document.getElementById('cwNumVal2').value;

      if (val1 === '') { alert('Please provide at least one value.'); return; }
      if (op === 'between' && val2 === '') { alert('Please provide a second value for "between".'); return; }

      const values = [Number(val1)];
      if (op === 'between') values.push(Number(val2));

      clause = { type: 'numeric', qid, op, values };

    } else {
      const codes = Array.from($box.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value);
      if (!codes.length){ alert('Pick at least one option.'); return; }
      clause = { type: 'categorical', qid, codes };
    }
    // ==========================================================
    // END MODIFIED
    // ==========================================================

    if (!clause) return; // Should not happen

    if (kind === 'AND') g.cond.all.push(clause);
    else g.cond.any.push(clause);

    dedupeCond?.(g); // This might need updating if you want to prevent duplicate numeric conditions
    queueAutosave?.();
    renderPreviewBanner(document.getElementById('prefield-content-host'));
    setStatus('Condition added.', true);
    close();
  };
}

function openCondEditor(dimId, groupId){
  const banner = getCoreBanner();
  const dim = banner.dimensions.find(d => d.dim_id === dimId);
  const g = dim?.groups.find(x => x.group_id === groupId);
  if (!g) return;
  ensureGroupCond(g);

  function labelForClause(c){
    const q = findQuestionById(c.qid);
    const opts = getQuestionOptions(q);
    const map = new Map(opts.map(o=>[String(o.code), o.label]));
    const labs = c.codes.map(cd => `${map.get(String(cd)) ?? cd} (${cd})`);
    return `${c.qid}: ${labs.join(', ')}`;
  }

  const overlay = document.createElement('div');
  overlay.className = 'modal';
  overlay.innerHTML = `
    <div class="modal-panel" onclick="event.stopPropagation()">
      <div class="modal-header">
        <h3>Create/Edit equation</h3>
        <button class="icon-btn" id="eqClose">✕</button>
      </div>
      <div class="modal-body">
        <div>
          <div class="subhead">MUST match all (AND)</div>
          <div id="eqAll"></div>
        </div>
        <div>
          <div class="subhead" style="margin-top:8px;">Match any (OR)</div>
          <div id="eqAny"></div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn" id="eqClear">Clear all</button>
        <button class="btn primary" id="eqDone">Done</button>
      </div>
    </div>
    <div class="modal-backdrop"></div>`;

  const $all = overlay.querySelector('#eqAll');
  const $any = overlay.querySelector('#eqAny');

  function redraw(){
    $all.innerHTML = g.cond.all.length
      ? g.cond.all.map((c,i)=>`
          <div class="stack" style="justify-content:space-between; margin:6px 0;">
            <span>${escapeHTML(labelForClause(c))}</span>
            <span class="stack">
              <button class="btn" data-move="to-or" data-i="${i}">→ OR</button>
              <button class="btn" data-edit="all" data-i="${i}">✎ Edit</button>
              <button class="btn danger" data-del="all" data-i="${i}">🗑️</button>
            </span>
          </div>`).join('')
      : `<div class="muted">None</div>`;

    $any.innerHTML = g.cond.any.length
      ? g.cond.any.map((c,i)=>`
          <div class="stack" style="justify-content:space-between; margin:6px 0;">
            <span>${escapeHTML(labelForClause(c))}</span>
            <span class="stack">
              <button class="btn" data-move="to-and" data-i="${i}">
                ${(c.codes && c.codes.length > 1) ? 'Split → AND' : '→ AND'}
              </button>
              <button class="btn" data-edit="any" data-i="${i}">✎ Edit</button>
              <button class="btn danger" data-del="any" data-i="${i}">🗑️</button>
            </span>
          </div>`).join('')
      : `<div class="muted">None</div>`;
  }

  overlay.addEventListener('click', (e)=>{
    const mv = e.target.closest('[data-move]');
    const del= e.target.closest('[data-del]');
    const ed = e.target.closest('[data-edit]');
    if (mv){
      const dir = mv.dataset.move, i = +mv.dataset.i;
      if (dir === 'to-or') {
        const moved = g.cond.all.splice(i, 1)[0];
        if (!moved) return;
        const existing = g.cond.any.find(c => c.qid === moved.qid);
        if (existing) {
          const set = new Set([...(existing.codes||[]), ...(moved.codes||[])]);
          existing.codes = Array.from(set);
        } else {
          g.cond.any.push(moved);
        }
      }
      if (dir === 'to-and') {
        const moved = g.cond.any.splice(i, 1)[0];          // { qid, codes: [...] }
        if (!moved) return;
        const { qid, codes = [] } = moved;
        if (codes.length <= 1) {
          g.cond.all.push({ qid, codes: codes.slice() });
        } else {
          // split OR codes into separate AND clauses
          codes.forEach(cd => g.cond.all.push({ qid, codes: [cd] }));
        }
      }

      redraw(); queueAutosave?.(); renderPreviewBanner(document.getElementById('prefield-content-host'));
    }
    if (del){
      const which = del.dataset.del, i = +del.dataset.i;
      if (which === 'all') g.cond.all.splice(i,1);
      else g.cond.any.splice(i,1);
      redraw(); queueAutosave?.(); renderPreviewBanner(document.getElementById('prefield-content-host'));
    }
    if (ed){
      const which = ed.dataset.edit, i = +ed.dataset.i;
      if (which === 'all') openCondWizard('AND', dimId, groupId);
      else openCondWizard('OR', dimId, groupId);
    }
  });

  function openClauseEditor(slot, idx){
    const clause = g.cond[slot][idx];
    if (!clause) return;

    // Build question list (allow switching if you want; or lock it by hiding the select)
    const qOpts = state.questions.map(q => `<option value="${q.id}">${escapeHTML(q.id)} — ${escapeHTML(q.text||'')}</option>`).join('');
    const overlay = document.createElement('div');
    overlay.className = 'modal';
    overlay.innerHTML = `
      <div class="modal-panel" onclick="event.stopPropagation()">
        <div class="modal-header">
          <h3>Edit condition</h3>
          <button class="icon-btn" id="ceClose">✕</button>
        </div>
        <div class="modal-body">
          <label>Pick a question
            <select id="ceQ">${qOpts}</select>
          </label>
          <div id="ceOpts" class="stack" style="flex-wrap:wrap; gap:8px;"></div>
        </div>
        <div class="modal-footer">
          <button class="btn" id="ceCancel">Cancel</button>
          <button class="btn primary" id="ceSave">Save</button>
        </div>
      </div>
      <div class="modal-backdrop"></div>`;
    document.body.appendChild(overlay);

    const $q = overlay.querySelector('#ceQ');
    const $box = overlay.querySelector('#ceOpts');
    $q.value = clause.qid; // preselect current qid

    function drawOpts(){
      const q = findQuestionById($q.value);
      const opts = getQuestionOptions(q);
      const selected = new Set((clause.codes||[]).map(String));
      $box.innerHTML = opts.length
        ? opts.map(o => `
            <label class="pill">
              <input type="checkbox" value="${escapeHTML(o.code)}" ${selected.has(String(o.code))?'checked':''}/>
              ${escapeHTML(o.label)} <span class="muted">(${escapeHTML(o.code)})</span>
            </label>`).join('')
        : `<div class="muted">This question has no selectable options.</div>`;
    }
    $q.onchange = drawOpts;
    drawOpts();

    function close(){ overlay.remove(); }
    overlay.querySelector('#ceClose').onclick = close;
    overlay.querySelector('#ceCancel').onclick = close;

    overlay.querySelector('#ceSave').onclick = ()=>{
      const qid = $q.value;
      const codes = Array.from($box.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value);
      if (!codes.length){
        // if nothing selected, remove the clause
        g.cond[slot].splice(idx,1);
      } else {
        // update/replace the clause
        g.cond[slot][idx] = { qid, codes: Array.from(new Set(codes)) };
      }
      dedupeCond?.(g);
      queueAutosave?.();
      renderPreviewBanner(document.getElementById('prefield-content-host'));
      redraw();  // refresh the editor lists
      close();
    };
  }

  overlay.querySelector('#eqClear').onclick = ()=>{
    g.cond.all = []; g.cond.any = [];
    redraw(); queueAutosave?.(); renderPreviewBanner(document.getElementById('prefield-content-host'));
  };
  overlay.querySelector('#eqDone').onclick = ()=> overlay.remove();
  overlay.querySelector('#eqClose').onclick = ()=> overlay.remove();

  document.body.appendChild(overlay);
  redraw();
}

/************* DASHBOARD *************/
function getProjects() {
  try { return JSON.parse(localStorage.getItem(PROJECTS_KEY) || '[]'); }
  catch { return []; }
}
function saveProjects(list) {
  localStorage.setItem(PROJECTS_KEY, JSON.stringify(list));
}

/** Ensure the current in-memory project is present in the Projects list + saved */
function touchCurrentIntoProjects() {
  const list = getProjects();
  const idx  = list.findIndex(p => p.id === state.project.id);

  const entry = {
    id: state.project.id,
    name: state.project.name || 'Untitled',
    client: state.project.client || '',
    version: state.project.version || '0.1.0',
    updated_at: new Date().toISOString(),
    favorite: !!(list[idx]?.favorite),
    status: list[idx]?.status || 'Draft'
  };

  if (idx >= 0) list[idx] = entry;
  else list.unshift(entry);

  saveProjects(list);
  localStorage.setItem(
    `proj:${state.project.id}`,
    JSON.stringify({ project: state.project, globals: state.globals, questions: state.questions })
  );
}

/* ----- Core render ----- */
function renderDashboard(root){
  const list = getProjects(); // always read fresh

  // --- status counts ---
  const total    = list.length;
  const draft    = list.filter(p => p.status === 'Draft').length;
  const active   = list.filter(p => p.status === 'Active').length;
  const archived = list.filter(p => p.status === 'Archived').length;

  // --- client counts (normalized) ---
  const clientCounts = {};
  for (const p of list) {
    const key = (p.client || '').trim() || 'Unspecified';
    clientCounts[key] = (clientCounts[key] || 0) + 1;
  }
  // stable-ish order: alphabetical, with “Unspecified” last
  const byClient = Object.entries(clientCounts)
    .sort((a, b) => (a[0] === 'Unspecified') - (b[0] === 'Unspecified') || a[0].localeCompare(b[0]));

  root.innerHTML = `
    <section class="app-grid" style="grid-template-columns: 1fr;">
      <div class="card">
        <div class="card-header">
          <div class="stack">
            <strong>Projects</strong>
            <input id="dashSearch" placeholder="Search by name/client..." style="width:240px"/>
            <select id="dashFilter">
              <option value="">All</option><option>Draft</option><option>Active</option><option>Archived</option>
            </select>
          </div>
          <div class="stack">
            <button id="dashNew" class="primary">+ New Project</button>
            <button id="dashOpenCurrent">Open Current</button>
          </div>
        </div>

        <div class="stats-wrap">
          <div class="stats-block">
            <div class="stat-title">Overview</div>
            <div class="stats-pills">
              <span class="pill strong">Total: ${total}</span>
              <span class="pill">Draft: ${draft}</span>
              <span class="pill">Active: ${active}</span>
              <span class="pill">Archived: ${archived}</span>
            </div>
          </div>

          <div class="client-stats">
            <div class="stat-title">Client Projects Totals</div>
            <ul>
              ${byClient.length
                ? byClient.map(([name, count]) => `
                    <li>
                      <span class="client-name">${escapeHTML(name)}</span>
                      <span class="client-count">${count}</span>
                    </li>
                  `).join('')
                : `<li><span class="muted">No projects yet.</span></li>`
              }
            </ul>
          </div>
        </div>

        <div class="card-content">
          <div class="grid" id="projGrid"></div>
        </div>
      </div>
    </section>`;

  const grid = $('#projGrid');

  const draw = (rows)=>{
    grid.innerHTML = rows.map(p=>`
      <div class="card project-card">
        <div class="card-content">
          <div class="stack" style="justify-content:space-between;">
            <div><strong>${escapeHTML(p.name)}</strong></div>
            <button class="pill" data-fav="${p.id}">⭐ ${p.favorite? 'Fav' : 'Star'}</button>
          </div>
          <div class="meta">${escapeHTML(p.client||'–')} • v${escapeHTML(p.version||'')} • ${new Date(p.updated_at).toLocaleString()}</div>
          <div class="stack" style="margin-top:10px; flex-wrap:wrap;">
            <button data-open="${p.id}">Open</button>
            <button data-dup="${p.id}">Duplicate</button>
            <button data-exp="${p.id}">Export JSON</button>
            <button data-genq="${p.id}">📝 QRE</button>
            <button data-genx="${p.id}">⚙️ Tab</button>
            <button data-del="${p.id}" class="danger">🗑️ Delete</button>
            <select data-status="${p.id}">
              <option ${p.status==='Draft'?'selected':''}>Draft</option>
              <option ${p.status==='Active'?'selected':''}>Active</option>
              <option ${p.status==='Archived'?'selected':''}>Archived</option>
            </select>
          </div>
        </div>
      </div>`).join('');

    $$('[data-open]').forEach(b=> b.onclick = ()=> openProjectById(b.dataset.open));
    $$('[data-dup]').forEach(b=> b.onclick = ()=> duplicateProjectById(b.dataset.dup));
    $$('[data-exp]').forEach(b=> b.onclick = ()=> exportProjectById(b.dataset.exp));
    $$('[data-genq]').forEach(b=> b.onclick = ()=> openAndGen(b.dataset.genq, 'qre'));
    $$('[data-genx]').forEach(b=> b.onclick = ()=> openAndGen(b.dataset.genx, 'tab'));
    $$('[data-fav]').forEach(b=> b.onclick = ()=> toggleFav(b.dataset.fav));
    $$('[data-status]').forEach(sel=> sel.onchange = ()=> setStatusFor(sel.dataset.status, sel.value));

    // delete → redraw everything (cards + stats + client list)
    $$('[data-del]').forEach(b => b.onclick = () => {
      const id = b.dataset.del;
      const projName = getProjects().find(p => p.id === id)?.name || 'this project';
      if (!confirm(`Are you sure you want to permanently delete "${projName}"? This cannot be undone.`)) return;

      localStorage.removeItem(`proj:${id}`);
      const updated = getProjects().filter(p => p.id !== id);
      saveProjects(updated);
      // re-render the entire dashboard so stats & client list refresh
      renderDashboard(root);
    });
  };

  // initial draw of cards
  draw(list);

  // controls
  $('#dashNew').onclick = openCreateProjectModal;
  $('#dashOpenCurrent').onclick = ()=>{ location.hash = '#/editor'; };

  $('#dashSearch').oninput = (e)=>{
    const q = e.target.value.toLowerCase();
    const f = $('#dashFilter').value;
    const rows = list.filter(p =>
      (!f || p.status === f) &&
      (p.name.toLowerCase().includes(q) || (p.client||'').toLowerCase().includes(q))
    );
    draw(rows);
  };
  $('#dashFilter').onchange = ()=> $('#dashSearch').oninput({target:$('#dashSearch')});
}

/* ----- Project helpers ----- */
function openProjectById(id){
  const raw = localStorage.getItem(`proj:${id}`);
  const stash = raw ? JSON.parse(raw) : null;
  if (!stash) { 
    setStatus?.("Project not found.", false);
    return;
  }

  // Safe assignments with fallbacks
  state.project   = stash.project   || state.project || {};
  state.globals   = stash.globals   || state.globals || {};
  state.questions = Array.isArray(stash.questions) ? stash.questions : [];

  // <<< NEW: upgrade model to include Step 1 fields >>>
  migrateProjectModel?.();

  // basic UX defaults
  ui_state.active_question_index = state.questions.length ? 0 : null;

  // persist + render
  autosaveNow?.();
  location.hash = '#/editor';
  renderRoute?.();
  setStatus?.("Project loaded.", true);
}

function duplicateProjectById(id) {
  const stash = JSON.parse(localStorage.getItem(`proj:${id}`) || 'null');
  if (!stash) return;

  const copy = JSON.parse(JSON.stringify(stash));
  copy.project.id = 'proj-' + Math.random().toString(16).slice(2,10);
  copy.project.name = (copy.project.name || 'Project') + ' (Copy)';
  localStorage.setItem(`proj:${copy.project.id}`, JSON.stringify(copy));

  const list = getProjects();
  list.unshift({
    id: copy.project.id,
    name: copy.project.name,
    client: copy.project.client,
    version: copy.project.version,
    updated_at: new Date().toISOString(),
    favorite: false,
    status: 'Draft'
  });
  saveProjects(list);
  renderRoute();
}

function exportProjectById(id) {
  const stash = JSON.parse(localStorage.getItem(`proj:${id}`) || 'null');
  if (!stash) return;
  const data = JSON.stringify(stash, null, 2);
  const blob = new Blob([data], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `${(stash.project.name || 'project').replace(/[^\w\-]+/g, '_')}.json`;
  a.click();
  URL.revokeObjectURL(a.href);
}

function toggleFav(id) {
  const list = getProjects();
  const i = list.findIndex(p => p.id === id);
  if (i < 0) return;
  list[i].favorite = !list[i].favorite;
  saveProjects(list);
  renderRoute();
}

function setStatusFor(id, status) {
  const list = getProjects();
  const i = list.findIndex(p => p.id === id);
  if (i < 0) return;
  list[i].status = status;
  saveProjects(list);
}

function openAndGen(id, which) {
  openProjectById(id);
  setTimeout(() => {
    if (which === 'qre') $('#generateDocx').click();
    else $('#generateXlsx').click();
  }, 150);
}

/* Creates a fresh, empty project in memory and persists it */
function newProject() {
  state.project = {
    id: 'proj-' + Math.random().toString(16).slice(2,10),
    name: '',
    client: '',
    version: '0.1.0',
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    notes: ''
  };
  state.questions = [];
  ui_state.active_question_index = null;
  autosaveNow();
  touchCurrentIntoProjects();
}

/* ========================================================
   Modal Control + Create handler
   ======================================================== */
function openCreateProjectModal() {
  // clear fields
  const f = (id) => document.getElementById(id);
  f('cp-name').value   = '';
  f('cp-client').value = '';
  f('cp-dates').value  = '';
  f('cp-notes').value  = '';

  const modal = document.getElementById('createProjectModal');
  if (!modal) return;

  // allow Enter to submit (no Shift)
  modal.onkeydown = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      createProjectFromModal();
    }
  };

  modal.classList.remove('is-hidden');
  f('cp-name').focus();
}

function closeCreateProjectModal() {
  const modal = document.getElementById('createProjectModal');
  if (modal) {
    modal.onkeydown = null;
    modal.classList.add('is-hidden');
  }
}

/** Called by the footer button in the modal */
function createProjectFromModal() {
  const name   = (document.getElementById('cp-name')?.value || '').trim();
  const client = (document.getElementById('cp-client')?.value || '').trim();
  const dates  = (document.getElementById('cp-dates')?.value || '').trim();
  const notes  = (document.getElementById('cp-notes')?.value || '').trim();

  // new project object
  state.project = {
    id: 'proj-' + Math.random().toString(16).slice(2,10),
    name: name || 'Untitled',
    client,
    version: '0.1.0',
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
    notes
  };
  if (dates) state.project.important_dates = dates;

  // reset questions and persist
  state.questions = [];
  ui_state.active_question_index = null;
  autosaveNow();
  touchCurrentIntoProjects();

  // close modal + go to editor
  closeCreateProjectModal();
  location.hash = '#/editor';
}

/************* EDITOR *************/
function renderEditor(root){
  const tab = (ui_state.active_prefield_tab || 'screener');       // 'screener' | 'main' | 'tabplan' | 'banner'
  const isTwoPanel = (tab === 'screener' || tab === 'main');

  // Left column (only for Screener/Main)
  const leftPanelHTML = isTwoPanel ? `
    <div class="left-panel">
      <div id="question-list" class="stack" style="flex-direction:column; align-items:stretch;"></div>
      <div class="stack">
        ${tab==='screener'
          ? `<button id="addScreener" style="flex:1;">+ Screener</button>`
          : `<button id="addMain" style="flex:1;">+ Main Survey</button>
             <button id="addHidden" style="flex:1;">+ Hidden</button>
             <button id="addQC" style="flex:1;">+ Red Herring</button>`
        }
      </div>
    </div>
  ` : ``;

  // Right column host:
  // - Always include the .pv-tabs + #pv-* panels (even though pills are hidden in sidebar mode)
  // - For two-panel tabs, #editor-panel is where question editor renders
  // - For single-panel tabs, #prefield-content-host is where Tab/Banner previews render
  const rightPanelContentHTML = `
    <div class="right-panel-content">
      <!-- Hidden pills row (used by sidebar logic; CSS hides in sidebar-mode) -->
      <div class="pv-tabs">
        <button class="pv-tab ${tab==='screener'?'active':''}" data-pvtab="scr">Screener</button>
        <button class="pv-tab ${tab==='main'?'active':''}"     data-pvtab="main">Main Survey</button>
        <button class="pv-tab ${tab==='tabplan'?'active':''}"  data-pvtab="tab">Tab Sheet</button>
        <button class="pv-tab ${tab==='banner'?'active':''}"   data-pvtab="ban">Banner</button>
      </div>

      <!-- Panels the sidebar toggles -->
      <section id="pv-scr"  class="pv-panel ${tab==='screener'?'active':''}"></section>
      <section id="pv-main" class="pv-panel ${tab==='main'?'active':''}"></section>
      <section id="pv-tab"  class="pv-panel ${tab==='tabplan'?'active':''}"></section>
      <section id="pv-ban"  class="pv-panel ${tab==='banner'?'active':''}"></section>

      ${isTwoPanel
        ? `<div id="editor-panel"></div>`
        : `<div id="prefield-content-host"></div>`
      }
    </div>
  `;

  // If single-column, collapse grid
  const gridStyle = isTwoPanel ? '' : 'style="grid-template-columns:1fr;"';
  const mainContentHTML = `
    <section class="app-grid" ${gridStyle}>
      ${leftPanelHTML}
      <div class="right-panel">
        ${rightPanelContentHTML}
      </div>
    </section>
  `;

  root.innerHTML = mainContentHTML;

  // ---- Render content for current tab ----
  if (isTwoPanel){
    const filter = (tab === 'screener') ? 'screener' : 'main';
    renderQuestionList(filter);
    renderEditorPanel(); // writes into #editor-panel

    // add buttons
    const $ = (sel)=>document.querySelector(sel);
    $('#addScreener') && ($('#addScreener').onclick = () => addQuestion('S'));
    $('#addMain')     && ($('#addMain').onclick     = () => addQuestion('Q'));
    $('#addHidden')   && ($('#addHidden').onclick   = () => addQuestion('H'));
    $('#addQC')       && ($('#addQC').onclick       = () => addQuestion('R'));
  } else {
    // Single panel previews
    const host = document.getElementById('prefield-content-host');
    if (tab === 'banner')  renderPreviewBanner(host);
    if (tab === 'tabplan') renderPreviewTabSheet(host);
  }

  renderProjectHeader();
  wireEditorShortcuts();

  // ---- Wire tertiary tab clicks (Screener/Main/Tab/Banner) ----
  document.querySelectorAll('[data-prefield-tab]').forEach(btn => {
    btn.onclick = (e) => {
      const next = e.currentTarget.dataset.prefieldTab;
      if (!next) return;
      ui_state.active_prefield_tab = next;

      // Maintain pv-panel active class in sync with our state so sidebar + pills stay aligned
      const map = { screener:'scr', main:'main', tabplan:'tab', banner:'ban' };
      const key = map[next];
      if (key){
        document.querySelectorAll('.pv-tab').forEach(b=>b.classList.toggle('active', b.dataset.pvtab === key));
        document.querySelectorAll('.pv-panel').forEach(p=>p.classList.toggle('active', p.id === `pv-${key}`));
      }

      renderEditor(root);
    };
  });

  // ---- Bridge: when a hidden pill is clicked (or sidebar syncs them), update our active tab ----
  document.querySelectorAll('.pv-tab').forEach(pill=>{
    pill.addEventListener('click', ()=>{
      const v = pill.dataset.pvtab;       // 'scr' | 'main' | 'tab' | 'ban'
      const map = { scr:'screener', main:'main', tab:'tabplan', ban:'banner' };
      const next = map[v];
      if (next && next !== ui_state.active_prefield_tab){
        ui_state.active_prefield_tab = next;
        renderEditor(root);
      }
    });
  });
}

function renderProjectHeader(){
  $("#projName").value = state.project.name || "";
  $("#projClient").value = state.project.client || "";
  $("#projVersion").value = state.project.version || "0.1.0";
}
$("#projName").addEventListener("input", e=>{ state.project.name=e.target.value; queueAutosave(); });
$("#projClient").addEventListener("input", e=>{ state.project.client=e.target.value; queueAutosave(); });
$("#projVersion").addEventListener("input", e=>{ state.project.version=e.target.value; queueAutosave(); });

// ---------- SUMMARIES (numeric, table, open end)
function numericSummary(q){
  const N = q.numeric || {};
  const hasRange = (N.min != null || N.max != null);
  const range = hasRange ? ` ${N.min ?? ''}–${N.max ?? ''}` : '';
  if (q.type === 'numeric_time')  return `time${range} ${N.time_unit || ''}`.trim();
  if (q.type === 'numeric_count') return `count${range} ${N.unit || ''}`.trim();
  if (q.type === 'numeric_open')  return `num${range} ${N.unit || ''}`.trim();
  return '';
}

function openSummary(q){
  if (q.type !== 'open_end') return '';
  const O = q.open || {};
  const k = O.limit_kind || '';
  const a = O.min, b = O.max;
  // base label always; details only if kind chosen AND at least one bound set
  const detail = (k && (a != null || b != null)) ? ` ${a ?? ''}–${b ?? ''} ${k}` : '';
  return ` • open${detail}`;
}

function summaryFor(q){
  const base = (q.mode === 'open') ? 'open_end' : `${q.type || 'single'}`;
  const scal = q.scale?.points ? ` • ${q.scale.points}pt` : '';
  const opts = (q.options?.length || 0) ? ` • ${q.options.length} opt` : '';
  const stm  = (q.statements?.length || 0) ? ` • ${q.statements.length} stmts` : '';
  const num  = /^numeric_/.test(q.type || '') ? ` • ${numericSummary(q)}` : '';
  const tbl  = (q.grid?.rows?.length || 0) || (q.grid?.cols?.length || 0)
    ? ` • table ${q.grid.rows.length}×${q.grid.cols.length}` : '';
  const open = openSummary(q);

  return base + scal + opts + stm + num + tbl + open;
}

function renderQuestionList(filter = 'all'){
  const list = $("#question-list");
  if (!list) return;
  list.innerHTML = "";

  const questionsToRender = state.questions
    .map((q, originalIndex) => ({ q, originalIndex }))
    .filter(({ q }) => {
      if (filter === 'screener') {
        return String(q.id || '').toUpperCase().startsWith('S');
      }
      if (filter === 'main') {
        return !String(q.id || '').toUpperCase().startsWith('S');
      }
      return true; // 'all' or default
    });

  questionsToRender.forEach(({ q, originalIndex }) => {
    const item = document.createElement("div");
    item.className = "q-item" + (originalIndex === ui_state.active_question_index ? " active" : "");
    item.dataset.index = originalIndex;
    item.draggable = true;
    item.innerHTML = `
      <div class="stack">
        <span class="tag">${q.id}</span>
        <span class="text">${escapeHTML(q.text || "...")}</span>
      </div>
      <div class="summary">${summaryFor(q)}</div>`;

    item.onclick = () => {
      ui_state.active_question_index = originalIndex;
      ui_state.active_tab = 'main';
      renderEditorPanel();
      renderQuestionList(filter); // Re-render list to update active class
    };
    item.addEventListener("dragstart", e => { e.dataTransfer.setData("text/plain", originalIndex); });
    item.addEventListener("dragover", e => e.preventDefault());
    item.addEventListener("drop", e => {
      e.preventDefault();
      e.stopPropagation();
      const from = +e.dataTransfer.getData("text/plain");
      const to = originalIndex;
      if (isNaN(from) || isNaN(to) || from === to) return;

      const [movedItem] = state.questions.splice(from, 1);
      
      // Find the correct insertion point in the original array
      const targetIndexInState = state.questions.findIndex(question => question.id === q.id);
      
      if (from < to) {
          // If moving down, the target index might have shifted
           state.questions.splice(targetIndexInState, 0, movedItem);
      } else {
          // If moving up
           state.questions.splice(targetIndexInState, 0, movedItem);
      }
      
      // Update active index to the new position of the moved item
      ui_state.active_question_index = state.questions.findIndex(question => question.id === movedItem.id);

      renderQuestionList(filter);
      renderEditorPanel();
      queueAutosave();
    });
    list.appendChild(item);
  });
}


/* -----------------------
   MODE <-> TYPE MAPPING
   ----------------------- */
function inferModeFromType(q){
  const t = q.type || 'single';
  if (t.startsWith('numeric_') || t === 'numeric') return 'numeric';
  if (t.startsWith('grid_') || (t.startsWith('likert_') && (q.statements?.length||0) >= 2)) return 'table';
  return 'list';
}
function ensureMode(q){ q.mode ||= inferModeFromType(q); return q.mode; }
function getListSelection(q){ return (q.type === 'multi' || q.type === 'grid_multi') ? 'multi' : 'single'; }
function setListSelection(q, sel){ if (q.mode !== 'list') return; q.type = (sel === 'multi') ? 'multi' : 'single'; }
function harmonizeTypeFromMode(q){
  const mode = ensureMode(q);
  if (mode === 'numeric'){
    if (!/^numeric_/.test(q.type||'')) q.type = 'numeric_open';
    return;
  }
  if (mode === 'table'){
    q.grid ||= { rows: q.statements || [], cols: (q.scale?.labels || []) };
    q.type = (q.type === 'grid_multi') ? 'grid_multi' : 'grid_single';
    return;
  }
  if (mode === 'open'){
    q.type = 'open_text';      // canonical subtype
    q.options = [];            // strip list/table artifacts
    q.statements = [];
    q.scale = null;
    q.grid = null;
    return;
  }
  // list (fallback)
  const hasScale = !!q.scale?.points;
  const stmts = q.statements?.length || 0;
  if (hasScale && stmts <= 1) q.type = 'likert_single';
  else if (hasScale && stmts === 2) q.type = 'likert_dual';
  else if (hasScale && stmts >= 3) q.type = 'likert_multi';
  else q.type = getListSelection(q);
}
function syncTableFacets(q){
  if (q.mode === 'table' && q.grid){
    q.statements = [...q.grid.rows];
    q.scale ||= {};
    q.scale.labels = [...q.grid.cols];
    q.scale.points = q.grid.cols.length || q.scale.points || null;
  }
}

/* -------------
   NUMERIC API
   ------------- */
// Guarantees a numeric object exists for question i, with safe defaults.
function ensureNumeric(i){
  const q = state.questions[i];
  if (!q.numeric) q.numeric = {};
  const n = q.numeric;
  if (n.min === undefined)        n.min = null;
  if (n.max === undefined)        n.max = null;
  if (n.unit === undefined)       n.unit = '';       // for numeric_open / numeric_count
  if (n.time_unit === undefined)  n.time_unit = '';  // for numeric_time
  if (n.placeholder === undefined)n.placeholder = ''; // e.g., "____ years"
  if (n.zero_pad === undefined)   n.zero_pad = 0;    // 0 = none, 2 = pad to "01"
  if (n.integer_only === undefined)n.integer_only = true;
  return n;
}

// Normalizes numeric updates; blanks become null, numbers parse safely.
function updateNumeric(i, key, value){
  ensureNumeric(i);
  const n = state.questions[i].numeric;

  if (key === 'integer_only') {
    n.integer_only = !!value;
  } else if (key === 'min' || key === 'max') {
    if (value === '' || value === null) n[key] = null;
    else {
      const num = Number(value);
      n[key] = Number.isFinite(num) ? num : null;
    }
  } else if (key === 'zero_pad') {
    // Accept only 0 or 2; blank -> 0
    const z = String(value).trim() === '' ? 0 : Number(value);
    n.zero_pad = (z === 2) ? 2 : 0;
  } else if (key === 'unit' || key === 'time_unit' || key === 'placeholder') {
    n[key] = String(value ?? '');
  }
  queueAutosave();
}

/* -------- EDITOR PANEL (Type UI removed entirely) -------- */
function renderEditorPanel(){
  const panel = $("#editor-panel");
  if (!panel) return;

  const i = ui_state.active_question_index;
  if (i === null || !state.questions[i]) { panel.innerHTML = ""; return; }

  const q = state.questions[i];

  ensureTabBucket(q); 
  syncNetsWithQuestion(q);

  // Keep type consistent with chosen mode & sync grid facets
  harmonizeTypeFromMode(q);
  syncTableFacets(q);

  // Ensure numeric sub-obj exists early so we can render without guards
  const N = ensureNumeric(i);

  const priorQs = state.questions
    .filter((_, j) => j < i)
    .map(qq => `<option value="${qq.id}">${qq.id}</option>`)
    .join("");

  const mode = ensureMode(q);

  // Always overwrite table helpers so stale functions can’t survive reloads
  window._tb_addRow = (ii) => { state.questions[ii].grid.rows.push(''); renderEditorPanel(); queueAutosave(); };
  window._tb_delRow = (ii, idx) => { state.questions[ii].grid.rows.splice(idx,1); renderEditorPanel(); queueAutosave(); };
  window._tb_updRow = (ii, idx, val) => { state.questions[ii].grid.rows[idx] = val; queueAutosave(); };

  window._tb_addCol = (ii) => { state.questions[ii].grid.cols.push(''); renderEditorPanel(); queueAutosave(); };
  window._tb_delCol = (ii, idx) => { state.questions[ii].grid.cols.splice(idx,1); renderEditorPanel(); queueAutosave(); };
  window._tb_updCol = (ii, idx, val) => { state.questions[ii].grid.cols[idx] = val; queueAutosave(); };

  // Create your own Preset 
  window.openPresetMaker = function(i){  const overlay = document.createElement('div');
  overlay.style.cssText = `
    position:fixed; inset:0; background:rgba(0,0,0,.35);
    display:flex; align-items:center; justify-content:center; z-index:1000;`;
  overlay.innerHTML = `
    <div class="card" style="width:640px; max-width:92vw;">
      <div class="card-header">
        <strong>Create a custom scale</strong>
        <div class="stack"><button id="pmClose">Close</button></div>
      </div>
      <div class="card-content">
        <div class="row"><div class="k">Name</div>
          <input id="pmName" placeholder="e.g., Usage intensity"/>
        </div>
        <div class="row"><div class="k">Description</div>
          <input id="pmDesc" placeholder="(optional)"/>
        </div>
        <div class="row"><div class="k">Labels</div>
          <textarea id="pmLabels" placeholder="One label per line, left → right"></textarea>
        </div>
        <div class="stack" style="justify-content:space-between;">
          <div class="muted">Tip: keep 3–10 labels. You can still edit after inserting.</div>
          <div class="stack">
            <button id="pmInsert">Insert only</button>
            <button id="pmSaveApply" class="primary">Save to presets & Insert</button>
          </div>
        </div>
      </div>
    </div>`;
  document.body.appendChild(overlay);

  const close = ()=> overlay.remove();
  overlay.querySelector('#pmClose').onclick = close;

  function parseLabels(){
    const raw = overlay.querySelector('#pmLabels').value;
    return raw.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  }
  function apply(labels){
    const q = state.questions[i];
    q.mode = 'table';
    q.grid ||= { rows: q.statements||[], cols: [] };
    q.grid.cols  = [...labels];
    q.scale    ||= {};
    q.scale.labels = [...labels];
    q.scale.points = labels.length;
    renderEditorPanel(); queueAutosave();
  }

  overlay.querySelector('#pmInsert').onclick = ()=>{
    const labels = parseLabels();
    if(labels.length < 2){ alert("Please provide at least 2 labels."); return; }
    apply(labels); close();
  };

  overlay.querySelector('#pmSaveApply').onclick = ()=>{
    const name   = overlay.querySelector('#pmName').value.trim();
    const desc   = overlay.querySelector('#pmDesc').value.trim();
    const labels = parseLabels();
    if(!name){ alert("Please provide a name."); return; }
    if(labels.length < 2){ alert("Please provide at least 2 labels."); return; }
    saveCustomPreset(labels.length, name, labels, desc);
    apply(labels); close();
  };

  // Render the initial list of net previews
  renderNetPreviews(i);

  // Wire up the "Add Net" button
  const addBtn = document.getElementById(`addNetBtn-${i}`);
  if (addBtn) {
    addBtn.onclick = () => {
      if (isNumericQuestion(q)) {
        openRangeNetEditor(i);
      } else {
        openCodesNetEditor(i);
      }
    };
  }
}

// safe tab-plan object so inputs don't error if not yet created
const tp = (q.exports && q.exports.tab_plan) ? q.exports.tab_plan : {};

panel.innerHTML = `
  <div class="card" style="flex-grow:1;">
    <div class="card-header">
      <span>Editing: <strong>${q.id}</strong></span>
      <div class="stack">
        <button onclick="saveQuestionToLibrary(${i})">💾 Save to Library</button>
        <button onclick="dupQ(${i})">Duplicate</button>
        <button class="danger" onclick="delQ(${i})">Delete</button>
      </div>
    </div>

    <div class="editor-tabs">
      <div class="tab-btn tab ${ui_state.active_tab==='main'?'active':''}"   data-tab="main">Main</div>
      <div class="tab-btn tab ${ui_state.active_tab==='logic'?'active':''}"  data-tab="logic">Logic & Base</div>
      <div class="tab-btn tab ${ui_state.active_tab==='tabplan'?'active':''}" data-tab="tabplan">Tab Plan</div>
    </div>

    <div class="card-content">
      <!-- ===== MAIN TAB ===== -->
      <div class="tab-content ${ui_state.active_tab==='main'?'active':''}">
        <div class="row"><div class="k">Question ID</div>
          <input value="${q.id}" oninput="updateQ(${i}, 'id', event.target.value)"/>
        </div>

        <div class="row"><div class="k">Mode</div>
          <div class="stack mode-row">
            <label class="mode-btn">
              <input type="radio" name="mode-${i}" value="list"   ${mode==='list'?'checked':''}
                onchange="state.questions[${i}].mode='list';   harmonizeTypeFromMode(state.questions[${i}]); renderEditorPanel();"/>
              <span>Item or list</span>
            </label>
            <label class="mode-btn">
              <input type="radio" name="mode-${i}" value="numeric" ${mode==='numeric'?'checked':''}
                onchange="state.questions[${i}].mode='numeric';harmonizeTypeFromMode(state.questions[${i}]); renderEditorPanel();"/>
              <span>Numeric</span>
            </label>
            <label class="mode-btn">
              <input type="radio" name="mode-${i}" value="table"  ${mode==='table'?'checked':''}
                onchange="state.questions[${i}].mode='table'; harmonizeTypeFromMode(state.questions[${i}]); renderEditorPanel();"/>
              <span>Table</span>
            </label>
            <label class="mode-btn">
              <input type="radio" name="mode-${i}" value="open"   ${mode==='open'?'checked':''}
                onchange="state.questions[${i}].mode='open';  harmonizeTypeFromMode(state.questions[${i}]); renderEditorPanel();"/>
              <span>Open End</span>
            </label>
          </div>
        </div>

        <!-- NEW: Question-level randomization controls -->
        ${mode==='list' ? `
        <div class="row"><div class="k">Randomization</div>
          <div class="stack">
            <label>
              <input type="radio" name="rand-${i}" value="none"
                ${(q.randomization?.mode||'none')!=='shuffle'?'checked':''}
                onchange="updateQ(${i},'randomization',{...(state.questions[${i}].randomization||{}),mode:'none'}); queueAutosave();"/>
              None
            </label>
            <label>
              <input type="radio" name="rand-${i}" value="shuffle"
                ${q.randomization?.mode==='shuffle'?'checked':''}
                onchange="updateQ(${i},'randomization',{...(state.questions[${i}].randomization||{}),mode:'shuffle'}); queueAutosave();"/>
              Shuffle options
            </label>
          </div>
        </div>
        ` : ''}

        <div class="row"><div class="k">Question Text</div>
          <textarea oninput="updateQ(${i}, 'text', event.target.value)">${q.text || ""}</textarea>
        </div>

        ${mode==='list' ? `
          <div class="row"><div class="k">Selection</div>
            <div class="stack select-row">
              <label class="select-btn">
                <input type="radio" name="listSel-${i}" value="single" ${getListSelection(q)==='single'?'checked':''}
                  onchange="setListSelection(state.questions[${i}], 'single'); queueAutosave(); renderQuestionList();"/>
                <span>Single</span>
              </label>
              <label class="select-btn">
                <input type="radio" name="listSel-${i}" value="multi" ${getListSelection(q)==='multi'?'checked':''}
                  onchange="setListSelection(state.questions[${i}], 'multi'); queueAutosave(); renderQuestionList();"/>
                <span>Multi</span>
              </label>
            </div>
          </div>

          <div class="row"><div class="k">Options</div>
            <div>
              ${(q.options||[]).map((o,j)=> `
                <div class="row option-row">
                  <div class="k">Option ${j+1}</div>
                  <div class="stack" style="flex-wrap:wrap; gap:10px; align-items:flex-start;">
                    <input style="flex:0 0 80px;" placeholder="Code" value="${o.code ?? ""}"
                           oninput="updateOpt(${i},${j},'code',event.target.value,true)"/>
                    <input placeholder="Label" value="${escapeHTML(o.label || '')}"
                           oninput="updateOpt(${i},${j},'label',event.target.value)"/>

                    <label class="chk">
                      <input type="checkbox" ${o.exclusive?'checked':''}
                             onchange="updateOpt(${i},${j},'exclusive',this.checked)"/> exclusive
                    </label>
                    <label class="chk">
                      <input type="checkbox" ${o.terminate?'checked':''}
                             onchange="updateOpt(${i},${j},'terminate',this.checked)"/> terminate
                    </label>

                    <!-- NEW: Anchor + Lock -->
                    <label>Anchor
                      <select onchange="updateOpt(${i},${j},'anchor', this.value || null)">
                        <option value="" ${!o.anchor?'selected':''}>—</option>
                        <option value="top" ${o.anchor==='top'?'selected':''}>Top</option>
                        <option value="bottom" ${o.anchor==='bottom'?'selected':''}>Bottom</option>
                      </select>
                    </label>
                    <label class="chk" title="Keep this option's position even if randomized">
                      <input type="checkbox" ${o.lock_randomize?'checked':''}
                             onchange="updateOpt(${i},${j},'lock_randomize',this.checked)"/> lock position
                    </label>

                    <!-- NEW: Export overrides -->
                    <input style="flex:0 0 140px;" placeholder="Custom code (export)"
                           value="${o.custom_code||''}"
                           oninput="updateOpt(${i},${j},'custom_code',this.value)"/>
                    <input style="flex:1 1 220px;" placeholder="Custom label (export)"
                           value="${o.custom_label||''}"
                           oninput="updateOpt(${i},${j},'custom_label',this.value)"/>

                    <button onclick="delOpt(${i},${j})">🗑️</button>
                  </div>
                </div>`).join('')}

              <div class="stack">
                <button onclick="addOpt(${i})">+ Add Option</button>
                <button onclick="bulkAddOptions(${i})">📋 Bulk Add</button>
              </div>
            </div>
          </div>

          <div class="row"><div class="k">Statements</div>
            <div>
              ${(q.statements||[]).map((s,j)=> `
                <div class="row">
                  <div class="k">Statement ${j+1}</div>
                  <div class="stack" style="flex-wrap:nowrap;">
                    <input value="${escapeHTML(s)}" oninput="updateStmt(${i},${j},event.target.value)"/>
                    <button onclick="delStmt(${i},${j})">🗑️</button>
                  </div>
                </div>`).join('')}
              <div class="stack">
                <button onclick="addStmt(${i})">+ Add Statement</button>
                <button onclick="bulkAddStatements(${i})">📋 Bulk Add</button>
              </div>
            </div>
          </div>

          <div class="row"><div class="k">Likert scale</div>
            <div class="grid2">
              <select onchange="updateScalePoints(${i}, this.value)">
                <option value="">(none)</option>
                ${[5,7,10].map(n=>`<option value="${n}" ${q.scale?.points==n?'selected':''}>${n}</option>`).join('')}
              </select>
              <input placeholder="Labels (pipe-separated: Strongly Disagree|...|Strongly Agree)"
                     value="${(q.scale?.labels||[]).join('|')}"
                     oninput="updateScaleLabels(${i}, this.value)" />
            </div>
            <small class="muted">If points + ≥3 statements ⇒ treated as Likert multi by the generator.</small>
          </div>
        ` : ''}

        ${mode==='numeric' ? `
          <div class="row"><div class="k">Numeric settings</div>
            <div>
              <div class="stack" style="flex-wrap:wrap; gap:10px;">
                <input style="width:120px" placeholder="Min (optional)" value="${N.min ?? ''}" oninput="updateNumeric(${i}, 'min', this.value)"/>
                <input style="width:120px" placeholder="Max (optional)" value="${N.max ?? ''}" oninput="updateNumeric(${i}, 'max', this.value)"/>

                ${q.type === 'numeric_time' ? `
                  <select style="width:160px" onchange="updateNumeric(${i}, 'time_unit', this.value)">
                    <option value="">(pick time unit)</option>
                    ${['seconds','minutes','hours','days','weeks','months','years'].map(u=>`<option value="${u}" ${N.time_unit===u?'selected':''}>${u}</option>`).join('')}
                  </select>
                ` : `
                  <input style="width:160px" placeholder="Unit (e.g., years)" value="${N.unit || ''}" oninput="updateNumeric(${i}, 'unit', this.value)"/>
                `}

                <input style="width:200px" placeholder="Placeholder (e.g., ____ years)" value="${N.placeholder || ''}" oninput="updateNumeric(${i}, 'placeholder', this.value)"/>

                <label class="stack" style="gap:6px;">
                  <span class="muted">Zero-pad</span>
                  <input style="width:80px" placeholder="0 or 2" value="${N.zero_pad ?? 0}" oninput="updateNumeric(${i}, 'zero_pad', this.value)"/>
                </label>

                <label class="stack" style="gap:6px;">
                  <input type="checkbox" ${N.integer_only ? 'checked' : ''} onchange="updateNumeric(${i}, 'integer_only', this.checked)"/>
                  <span class="muted">Integer only</span>
                </label>
              </div>
              <small class="muted">Tip: Leave min/max blank to allow any value. Use zero-pad=2 for inputs like 01–24.</small>
            </div>
          </div>
        ` : ''}

        ${mode==='open' ? `
          <div class="row"><div class="k">Use encouragement tool</div>
            <label class="stack">
              <input type="checkbox"
                ${q.open?.encourage ? 'checked' : ''}
                onchange="(state.questions[${i}].open ||= {}), state.questions[${i}].open.encourage = this.checked; queueAutosave();"/>
              <span class="muted">Enable gentle prompts if the response is empty/very short</span>
            </label>
          </div>

          <div class="row"><div class="k">Min / Max</div>
            <div class="stack" style="flex-wrap:wrap;">
              <select
                onchange="(state.questions[${i}].open ||= {}), state.questions[${i}].open.limit_kind = this.value || null; queueAutosave();">
                <option value="" ${!q.open?.limit_kind ? 'selected' : ''} disabled hidden>-- choose --</option>
                ${['words','characters','sentences'].map(k=>`<option value="${k}" ${q.open?.limit_kind===k?'selected':''}>${k}</option>`).join('')}
              </select>
              <input type="number" placeholder="Min (optional)" style="width:140px"
                value="${q.open?.min ?? ''}"
                oninput="(state.questions[${i}].open ||= {}), state.questions[${i}].open.min = this.value===''?null:+this.value; queueAutosave();"/>
              <input type="number" placeholder="Max (optional)" style="width:140px"
                value="${q.open?.max ?? ''}"
                oninput="(state.questions[${i}].open ||= {}), state.questions[${i}].open.max = this.value===''?null:+this.value; queueAutosave();"/>
            </div>
          </div>
        ` : ``}

        ${mode==='table' ? (() => {
          if (!q.grid) q.grid = { rows: (q.statements || []).slice(), cols: (q.scale?.labels || []).slice() };
          const G = q.grid;
          return `
            <div class="stack preset-wrap" style="margin-bottom:6px;">
              <button onclick="_tb_addRow(${i})">+ Row</button>
              <button onclick="_tb_addCol(${i})">+ Column</button>
              <button id="presetBtn-${i}" onclick="openPresetPicker(${i})">📊 Presets</button>
              <div id="presetHost-${i}" class="preset-panel"></div>
            </div>
            <div style="overflow:auto; border:1px solid var(--line); border-radius:8px;">
              <table style="width:100%; border-collapse:collapse; min-width:520px;">
                <thead>
                  <tr>
                    <th style="text-align:left; padding:6px; border-bottom:1px solid var(--line); width:42%;">Statements (rows)</th>
                    ${G.cols.map((c,ci)=>(`
                      <th style="text-align:left; padding:6px; border-bottom:1px solid var(--line);">
                        <input value="${escapeHTML(c)}" oninput="_tb_updCol(${i},${ci}, this.value)" />
                        <button onclick="_tb_delCol(${i},${ci})">🗑️</button>
                      </th>
                    `)).join('')}
                  </tr>
                </thead>
                <tbody>
                  ${G.rows.map((r,ri)=>(`
                    <tr>
                      <td style="padding:6px; border-bottom:1px solid var(--line);">
                        <input value="${escapeHTML(r)}" oninput="_tb_updRow(${i},${ri}, this.value)" />
                        <button onclick="_tb_delRow(${i},${ri})">🗑️</button>
                      </td>
                      ${G.cols.map(()=>'<td style="padding:6px; border-bottom:1px solid var(--line); color:var(--muted);">•</td>').join('')}
                    </tr>
                  `)).join('')}
                </tbody>
              </table>
            </div>
            <small class="muted">Rows = statements, Columns = scale/options. This will export as a grid/likert table; nets follow your rules.</small>
          `;
        })() : ''}

      </div>

      <!-- ===== LOGIC TAB ===== -->
      <div class="tab-content ${ui_state.active_tab==='logic'?'active':''}">
        <div class="row"><div class="k">Base Verbiage</div>
          <input value="${q.base && q.base.verbiage != null ? q.base.verbiage : ''}"
                oninput="updateBase(${i}, 'verbiage', event.target.value)"
                placeholder="Default: ${state.globals.default_base_verbiage}" />
        </div>

        <div class="row"><div class="k">Base Definition</div>
          <div>
            <input id="baseDef-${i}"
                  value="${q.base && q.base.definition ? q.base.definition : ''}"
                  oninput="updateBase(${i}, 'definition', event.target.value)"
                  placeholder="e.g., S1 in [2]" />

            <div class="stack muted" style="margin-top:8px; align-items:flex-start; flex-direction:column; gap:6px;">
              <small>Helper:</small>
              <div id="bbHost-${i}" class="stack" style="flex-direction:column; gap:8px; width:100%;"></div>
              <div class="stack" style="gap:8px;">
                <button class="primary" style="padding:4px 8px;" onclick="bbApply(${i})">Apply</button>
                <span class="muted" id="bbPrev-${i}"></span>
              </div>
            </div>
          </div>
        </div>

        <div class="row"><div class="k">Notes</div>
          <input value="${q.notes || ''}" oninput="updateQ(${i}, 'notes', event.target.value)" placeholder="e.g., Hidden, Red herring, etc." />
        </div>
      </div>

      <!-- ===== TAB PLAN TAB ===== -->
      <div class="tab-content ${ui_state.active_tab==='tabplan'?'active':''}">
        <div class="row">
          <div class="k">Nets</div>
          <div>
            <div id="netsPreviewHost-${i}" class="stack" style="flex-direction: column; align-items: flex-start; gap: 6px; margin-bottom: 8px;"></div>
            <button id="addNetBtn-${i}" class="btn primary">+ Add Net</button>
          </div>
        </div>
        <div class="row"><div class="k">Instructions</div>
          <textarea oninput="updateTabPlan(${i}, 'additional_instructions', this.value)"
                    placeholder="Add any specific instructions for the tabulation team.">${tp.additional_instructions || ''}</textarea>
        </div>
      </div>
    </div> `;

  drawBaseBuilder(i);
  renderNetPreviews(i);

  const addBtn = document.getElementById(`addNetBtn-${i}`);
  if (addBtn) {
    addBtn.onclick = () => {
      if (isNumericQuestion(q)) {
        openRangeNetEditor(i);
      } else {
        openCodesNetEditor(i);
      }
    };
  }

  function updateTabPlan(i, key, value){
    if (!state.questions[i]) return;
    if (!state.questions[i].exports) state.questions[i].exports = {};
    if (!state.questions[i].exports.tab_plan) state.questions[i].exports.tab_plan = {};
    state.questions[i].exports.tab_plan[key] = value;
    queueAutosave();
  }
}

function onOptionClick(q, opt){
  const isMulti = (getListSelection(q) === 'multi');

  if(isMulti && opt.exclusive){
    q.answer = [opt.code];                      // clear others
  }else if(isMulti){
    const a = Array.isArray(q.answer) ? q.answer.slice() : [];
    const ix = a.indexOf(opt.code);
    if(ix === -1) a.push(opt.code); else a.splice(ix,1);
    q.answer = a;
  }else{
    q.answer = opt.code;
  }
  if(opt.terminate){ state.disposition = "TERM_SCREEN"; }
  // re-render preview if needed
  renderPreview?.();
}

/* -------- Small editor helpers (hardened) -------- */
function setActiveTab(tab){
  ui_state.active_question_index = ui_state.active_question_index ?? null;
  ui_state.active_tab = tab || 'main';
  renderEditorPanel();
}

function updateQ(i, k, v){
  if (!state.questions[i]) return;
  state.questions[i][k] = v;
  if (k === 'id' || k === 'text' || k === 'type') {
      const activeFilter = ui_state.active_prefield_tab === 'screener' ? 'screener' : 'main';
      renderQuestionList(activeFilter);
  }
  queueAutosave();
}

function updateBase(i, k, v){
  if (!state.questions[i]) return;
  if (!state.questions[i].base) state.questions[i].base = {};
  // empty string means "use default" → store null
  var val = (v == null ? '' : String(v)).trim();
  state.questions[i].base[k] = val === '' ? null : val;
  queueAutosave();
}

function updateScalePoints(i, val){
  if (!state.questions[i]) return;
  if (!state.questions[i].scale) state.questions[i].scale = {};
  state.questions[i].scale.points = val ? parseInt(val, 10) : null;
  queueAutosave();
}

function updateScaleLabels(i, txt){
  if (!state.questions[i]) return;
  if (!state.questions[i].scale) state.questions[i].scale = {};
  var labels = String(txt || '').split('|').map(function(s){ return s.trim(); }).filter(Boolean);
  state.questions[i].scale.labels = labels;
  queueAutosave();
}

function addOpt(i){
  if (!state.questions[i]) return;
  if (!state.questions[i].options) state.questions[i].options = [];
  state.questions[i].options.push({ code: state.questions[i].options.length + 1, label: "" });
  renderEditorPanel(); queueAutosave();
}

function delOpt(i, j){
  if (!state.questions[i] || !state.questions[i].options) return;
  state.questions[i].options.splice(j, 1);
  renderEditorPanel(); queueAutosave();
}

function updateOpt(i, j, k, v, num){
  if (!state.questions[i] || !state.questions[i].options || !state.questions[i].options[j]) return;
  if (num) {
    var s = String(v == null ? '' : v).trim();
    state.questions[i].options[j][k] = (s === '') ? '' : (isFinite(parseInt(s, 10)) ? parseInt(s, 10) : s);
  } else {
    state.questions[i].options[j][k] = v;
  }
  queueAutosave();
}

function addStmt(i){
  if (!state.questions[i]) return;
  if (!state.questions[i].statements) state.questions[i].statements = [];
  state.questions[i].statements.push("");
  renderEditorPanel(); queueAutosave();
}

function delStmt(i, j){
  if (!state.questions[i] || !state.questions[i].statements) return;
  state.questions[i].statements.splice(j, 1);
  renderEditorPanel(); queueAutosave();
}

function updateStmt(i, j, v){
  if (!state.questions[i] || !state.questions[i].statements) return;
  state.questions[i].statements[j] = v;
  queueAutosave();
}

function bulkAddOptions(i){
  if (!state.questions[i]) return;
  var txt = prompt("Paste options (one per line). Use 'code\\tlabel', 'code label', '1) label', or just 'label'.");
  if (!txt) return;

  if (!state.questions[i].options) state.questions[i].options = [];
  var lines = txt.split(/\r?\n/).map(function(s){ return s.trim(); }).filter(Boolean);

  // Next code = 1 + current max numeric code (more reliable than .at(-1))
  var currentCodes = state.questions[i].options.map(function(o){ return o && isFinite(o.code) ? Number(o.code) : 0; });
  var maxCode = currentCodes.length ? Math.max.apply(null, currentCodes) : 0;
  var nextCode = isFinite(maxCode) ? (maxCode + 1) : (state.questions[i].options.length + 1);

  lines.forEach(function(line){
    var m = line.match(/^(\d+)[\s\.\-\t\)]\s*(.+)$/);
    if (m) {
      state.questions[i].options.push({ code: parseInt(m[1], 10), label: m[2].trim() });
    } else {
      var parts = line.split(/\t/);
      if (parts.length >= 2 && /^\d+$/.test(parts[0])) {
        state.questions[i].options.push({ code: parseInt(parts[0], 10), label: parts.slice(1).join(" ").trim() });
      } else {
        state.questions[i].options.push({ code: nextCode++, label: line });
      }
    }
  });

  renderEditorPanel(); queueAutosave();
}

function bulkAddStatements(i){
  if (!state.questions[i]) return;
  var txt = prompt("Paste statements (one per line).");
  if (!txt) return;
  if (!state.questions[i].statements) state.questions[i].statements = [];
  state.questions[i].statements.push.apply(
    state.questions[i].statements,
    txt.split(/\r?\n/).map(function(s){ return s.trim(); }).filter(Boolean)
  );
  renderEditorPanel(); queueAutosave();
}

function populatePriorOpts(i){
  var priorQSel = document.querySelector('#priorQ-' + i);
  var optSel    = document.querySelector('#priorOpt-' + i);
  if (!priorQSel || !optSel) return;

  var priorQId = priorQSel.value;
  var qq = state.questions.find(function(x){ return x.id === priorQId; });
  var opts = (qq && qq.options) ? qq.options : [];

  optSel.innerHTML = '<option value="">Pick Opt</option>' +
    opts.map(function(o){
      var lbl = escapeHTML(o && o.label ? o.label : '');
      return '<option value="' + (o && o.code != null ? o.code : '') + '">' +
             (o && o.code != null ? o.code : '') + ': ' + lbl + '</option>';
    }).join('');
}

function applyBase(i){
  var qSel = document.querySelector('#priorQ-' + i);
  var oSel = document.querySelector('#priorOpt-' + i);
  if (!qSel || !oSel) return;

  var pq = qSel.value;
  var po = oSel.value;
  if (!pq || !po) return;

  var newCondition = pq + ' in [' + po + ']';
  var existingDef = (state.questions[i].base && state.questions[i].base.definition) ? state.questions[i].base.definition : '';
  var finalDef = existingDef ? (existingDef + ' AND ' + newCondition) : newCondition;

  updateBase(i, 'definition', finalDef);
  renderEditorPanel(); // reflect change
}

function nextNumber(prefix){
  var n = 1;
  while (state.questions.some(function(q){ return q.id === (prefix + n); })) n++;
  return n;
}

function addQuestion(prefix){
  var id;
  if (prefix === 'S'){
    id = 'S' + nextNumber('S');
    state.questions.push({ id: id, type: 'single', text: '', options: [] });
  } else if (prefix === 'Q'){
    id = 'Q' + nextNumber('Q');
    state.questions.push({ id: id, type: 'single', text: '', options: [] });
  } else if (prefix === 'H'){
    id = 'Q' + nextNumber('Q') + '_H';
    state.questions.push({ id: id, type: 'single', text: '', notes: 'Hidden question', options: [] });
  } else if (prefix === 'R'){
    id = 'Q' + nextNumber('Q') + '_R';
    state.questions.push({ id: id, type: 'single', text: '', notes: 'Red herring', options: [] });
  }
  ui_state.active_question_index = state.questions.length - 1;
  const activeFilter = ui_state.active_prefield_tab === 'screener' ? 'screener' : 'main';
  renderQuestionList(activeFilter);
  renderEditorPanel();
  queueAutosave();
}


function delQ(i){
  if (!state.questions[i]) return;
  if (!confirm('Delete ' + state.questions[i].id + '?')) return;
  state.questions.splice(i, 1);
  ui_state.active_question_index = Math.min(i, state.questions.length - 1);
  if (state.questions.length === 0) ui_state.active_question_index = null;
  const activeFilter = ui_state.active_prefield_tab === 'screener' ? 'screener' : 'main';
  renderQuestionList(activeFilter);
  renderEditorPanel();
  queueAutosave();
}

function dupQ(i){
  if (!state.questions[i]) return;
  var copy = JSON.parse(JSON.stringify(state.questions[i]));
  var pref = (copy.id && copy.id.startsWith('S')) ? 'S' : 'Q';
  var m = copy.id && copy.id.match(/_([HR])$/);
  var suffix = m ? m[0] : '';
  copy.id = pref + nextNumber(pref) + suffix;
  state.questions.splice(i + 1, 0, copy);
  ui_state.active_question_index = i + 1;
  const activeFilter = ui_state.active_prefield_tab === 'screener' ? 'screener' : 'main';
  renderQuestionList(activeFilter);
  renderEditorPanel();
  queueAutosave();
}

function deleteNet(i, netIndex) {
  const q = state.questions[i];
  if (!q || !q.tab || !q.tab.nets) return;
  
  if (confirm('Are you sure you want to delete this net?')) {
    q.tab.nets.splice(netIndex, 1);
    renderEditorPanel(); // Re-render to show the change
    queueAutosave();
  }
}

function renderNetPreviews(i) {
  const q = state.questions[i];
  const host = document.getElementById(`netsPreviewHost-${i}`);
  if (!host) return;

  const nets = q.tab?.nets || [];
  if (!nets.length) {
    host.innerHTML = `<div class="muted">No nets defined yet.</div>`;
    return;
  }

  host.innerHTML = nets.map((net, index) => {
    let summaryText = '';
    
    if (net.kind === 'codes') {
      const labels = net.codes.map(code => getOptionLabel(q.id, code) || `Code ${code}`).join(', ');
      summaryText = `<b>Net:</b> ${escapeHTML(labels)}`;
    } 
    else if (net.kind === 'range') {
      // NEW logic to handle different operators
      switch (net.operator) {
        case '+':
          summaryText = `<b>Net:</b> ${net.value1}+`;
          break;
        case '>':
          summaryText = `<b>Net:</b> > ${net.value1}`;
          break;
        case '>=':
          summaryText = `<b>Net:</b> ≥ ${net.value1}`;
          break;
        case '<':
          summaryText = `<b>Net:</b> < ${net.value1}`;
          break;
        case '<=':
          summaryText = `<b>Net:</b> ≤ ${net.value1}`;
          break;
        case 'exact':
          summaryText = `<b>Net:</b> ${net.value1} (exact)`;
          break;
        case '-':
        default: // Default to the standard min-max range
          summaryText = `<b>Net:</b> ${net.value1} - ${net.value2}`;
          break;
      }
    }
    
    const netLabel = net.label ? `<span class="muted" style="margin-left: auto;">- ${escapeHTML(net.label)}</span>` : '';

    return `
      <div class="stack" style="padding: 8px 10px; border: 1px solid var(--line); border-radius: 8px; width: 100%; justify-content: space-between;">
        <div class="stack" style="flex-grow: 1; justify-content: flex-start; gap: 12px;">
          <span>${summaryText}</span>
          ${netLabel}
        </div>
        <div class="stack">
          <button class="btn" onclick="editNet(${i}, ${index})">Edit</button>
          <button class="btn danger" onclick="deleteNet(${i}, ${index})">Delete</button>
        </div>
      </div>
    `;
  }).join('');
}

function editNet(i, netIndex) {
  const q = state.questions[i];
  const net = q.tab.nets[netIndex];
  
  if (net.kind === 'range' || isNumericQuestion(q)) {
    openRangeNetEditor(i, netIndex);
  } else {
    openCodesNetEditor(i, netIndex);
  }
}

function openCodesNetEditor(i, netIndex = null) {
  const q = state.questions[i];
  const isEditing = netIndex !== null;
  const net = isEditing ? q.tab.nets[netIndex] : { label: '', codes: [] }; // Default for new net

  const options = getQuestionOptions(q);
  const selectedCodes = new Set(net.codes.map(String));

  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.innerHTML = `
    <div class="modal-panel" onclick="event.stopPropagation()">
      <div class="modal-header"><h3>${isEditing ? 'Edit Codes Net' : 'Add Codes Net'}</h3><button class="icon-btn" id="netClose">✕</button></div>
      <div class="modal-body">
        <label>
          <span>Net Label (Optional, e.g., "Manufacturer 1")</span>
          <input id="netLabel" type="text" value="${escapeHTML(net.label || '')}" />
        </label>
        <div>
          <span>Select Options to Include in Net</span>
          <div style="max-height: 200px; overflow-y: auto; border: 1px solid var(--line); border-radius: 8px; padding: 8px; margin-top: 4px;">
            ${options.map(o => `
              <label class="stack">
                <input type="checkbox" class="net-opt-cb" value="${o.code}" ${selectedCodes.has(o.code) ? 'checked' : ''}/>
                ${escapeHTML(o.label)} <span class="muted">(${o.code})</span>
              </label>`).join('') || '<div class="muted">This question has no options to select.</div>'}
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn ghost" id="netCancel">Cancel</button>
        <button class="btn primary" id="netSave">Save Net</button>
      </div>
    </div>
    <div class="modal-backdrop"></div>
  `;
  document.body.appendChild(modal);
  const closeModal = () => modal.remove();
  modal.querySelector('#netCancel').onclick = closeModal;
  modal.querySelector('.modal-backdrop').onclick = closeModal;

  modal.querySelector('#netSave').onclick = () => {
    const newLabel = modal.querySelector('#netLabel').value.trim() || null;
    const newCodes = Array.from(modal.querySelectorAll('.net-opt-cb:checked')).map(cb => cb.value);

    if (newCodes.length === 0) {
      alert('Please select at least one option.');
      return;
    }

    const newNet = createCodesNet({ label: newLabel, codes: newCodes });

    if (isEditing) {
      q.tab.nets[netIndex] = newNet;
    } else {
      q.tab.nets.push(newNet);
    }

    closeModal();
    renderEditorPanel();
    queueAutosave();
  };
}

function openRangeNetEditor(i, netIndex = null) {
  const q = state.questions[i];
  const isEditing = netIndex !== null;
  // Set defaults for a new net or use existing net data
  const net = isEditing ? q.tab.nets[netIndex] : { operator: '-', value1: '', value2: '' };

  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.innerHTML = `
    <div class="modal-panel" style="width: min(500px, 92vw);" onclick="event.stopPropagation()">
      <div class="modal-header"><h3>${isEditing ? 'Edit Numeric Net' : 'Add Numeric Net'}</h3><button class="icon-btn" id="netClose">✕</button></div>
      <div class="modal-body">
        <label>
          <span>Net Label (Optional, e.g., "Ages 18-34")</span>
          <input id="netLabel" type="text" value="${escapeHTML(net.label || '')}" />
        </label>
        <div class="stack" style="gap: 10px; align-items: center; justify-content: center; margin-top: 16px;">
          <input id="netValue1" type="number" placeholder="Value" value="${net.value1 ?? ''}" style="width: 120px;" />
          
          <select id="netOperator" style="width: 60px;">
            <option value="-" ${net.operator === '-' ? 'selected' : ''}>-</option>
            <option value="exact" ${net.operator === 'exact' ? 'selected' : ''}>(exact)</option>
            <option value="+" ${net.operator === '+' ? 'selected' : ''}>+</option>
            <option value="<" ${net.operator === '<' ? 'selected' : ''}><</option>
            <option value=">" ${net.operator === '>' ? 'selected' : ''}>></option>
            <option value="<=" ${net.operator === '<=' ? 'selected' : ''}>≤</option>
            <option value=">=" ${net.operator === '>=' ? 'selected' : ''}>≥</option>
          </select>

          <input id="netValue2" type="number" placeholder="Max" value="${net.value2 ?? ''}" style="width: 120px;" />
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn ghost" id="netCancel">Cancel</button>
        <button class="btn primary" id="netSave">Save Net</button>
      </div>
    </div>
    <div class="modal-backdrop"></div>
  `;
  document.body.appendChild(modal);

  const value1Input = modal.querySelector('#netValue1');
  const value2Input = modal.querySelector('#netValue2');
  const operatorSelect = modal.querySelector('#netOperator');

  // Function to toggle the second input box
  const toggleSecondInput = () => {
    // Only show the second input for the standard range operator '-'
    const show = operatorSelect.value === '-';
    value2Input.style.display = show ? '' : 'none';
  };

  // Set initial visibility and add event listener
  toggleSecondInput();
  operatorSelect.addEventListener('change', toggleSecondInput);

  const closeModal = () => modal.remove();
  modal.querySelector('#netClose').onclick = closeModal;
  modal.querySelector('#netCancel').onclick = closeModal;
  modal.querySelector('.modal-backdrop').onclick = closeModal;

  modal.querySelector('#netSave').onclick = () => {
    const newLabel = modal.querySelector('#netLabel').value.trim() || null;
    const operator = operatorSelect.value;
    const val1 = value1Input.value;
    const val2 = value2Input.value;

    if (val1 === '') {
      alert('Please enter at least one value.');
      return;
    }
    if (operator === '-' && val2 === '') {
      alert('Please enter both a minimum and maximum value for a range.');
      return;
    }
    
    // Create the new net object based on the operator
    const newNet = {
      kind: 'range', // Still a range kind, just more complex
      label: newLabel,
      operator: operator,
      value1: Number(val1),
      value2: operator === '-' ? Number(val2) : null
    };

    if (isEditing) {
      q.tab.nets[netIndex] = newNet;
    } else {
      q.tab.nets.push(newNet);
    }

    closeModal();
    renderEditorPanel();
    queueAutosave();
  };
}

function wireEditorShortcuts(){
  document.onkeydown = function(e){
    // Don't interfere if an input, textarea, or select is focused
    if (e.target.matches('input, textarea, select')) {
      return;
    }

    var i = (ui_state.active_question_index == null) ? -1 : ui_state.active_question_index;
    if (e.ctrlKey || e.metaKey){
      if (e.key.toLowerCase() === 's'){ e.preventDefault(); downloadJSON(); }
      if (e.key.toLowerCase() === 'd'){ e.preventDefault(); if (i >= 0) dupQ(i); }
    } else {
      if (e.key === 'ArrowUp'   && i > 0){
        ui_state.active_question_index = i - 1;
        const activeFilter = ui_state.active_prefield_tab === 'screener' ? 'screener' : 'main';
        renderQuestionList(activeFilter);
        renderEditorPanel();
      }
      if (e.key === 'ArrowDown' && i < state.questions.length - 1){
        ui_state.active_question_index = i + 1;
        const activeFilter = ui_state.active_prefield_tab === 'screener' ? 'screener' : 'main';
        renderQuestionList(activeFilter);
        renderEditorPanel();
      }
      if (e.key === 'Enter'     && i < 0 && state.questions.length){
        ui_state.active_question_index = 0;
        renderEditorPanel();
      }
    }
  };
}

/* ===== STEP 2: editor helpers ===== */
function updateOption(qIndex, optIndex, key, val){
  const q = state.questions[qIndex];
  if(!q?.options?.[optIndex]) return;
  q.options[optIndex][key] = val;
  // if your project uses updateOpt/updateQ, keep calling them elsewhere;
  // this helper just centralizes autosave + re-render
  queueAutosave?.();
  renderEditorPanel?.();
}

// alias to your existing updateQ if you have it
function updateQuestion(i, key, val){
  const q = state.questions[i];
  if(!q) return;
  q[key] = val;
  queueAutosave?.();
  renderEditorPanel?.();
}

function randomizedOptions(q){
  const opts = (q.options||[]).map((o, idx) => ({...o, _idx: idx}));
  if(q.randomization?.mode !== 'shuffle') return opts;

  const topAnchors    = opts.filter(o => o.anchor === 'top');
  const bottomAnchors = opts.filter(o => o.anchor === 'bottom');
  const locked        = opts.filter(o => o.lock_randomize && !o.anchor);
  const pool          = opts.filter(o => !o.anchor && !o.lock_randomize);

  for(let i = pool.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [pool[i], pool[j]] = [pool[j], pool[i]];
  }
  return [...topAnchors, ...locked, ...pool, ...bottomAnchors];
}



/* ====== Multi-clause Base Builder ====== */
// Ensure a builder for question i exists with at least one empty clause
function bbEnsure(i){
    ui_state.base_builders = ui_state.base_builders || {};
    const currentDefinition = state.questions[i]?.base?.definition || '';
    
    // Always re-parse the definitive source of truth
    ui_state.base_builders[i] = bbParseDefinition(currentDefinition);

    return ui_state.base_builders[i];
}

function bbParseDefinition(def = "") {
    const clauses = [];
    // Regex to find all clauses like (QID in [CODE]), optionally led by AND/OR
    const regex = /(AND|OR)?\s*\((\w+)\s+in\s+\[(\w+)\]\)/g;
    
    let match;
    while ((match = regex.exec(def)) !== null) {
        clauses.push({
            op: match[1] || null, // The first clause won't have a leading operator
            qid: match[2],
            opt: match[3]
        });
    }

    // If parsing fails or the string is empty, return a single default clause
    if (clauses.length === 0) {
        return [{ op: null, qid: "", opt: "" }];
    }

    return clauses;
}

// Build "(Q in [x]) OP (Q2 in [y]) ..." string from the current clauses
function bbBuildExpr(i){
  var clauses = bbEnsure(i);
  var parts = [];
  for (var idx = 0; idx < clauses.length; idx++){
    var c = clauses[idx];
    if (!c || !c.qid || !c.opt) continue;
    var lit = '(' + c.qid + ' in [' + c.opt + '])';
    if (idx > 0 && c.op) parts.push(c.op);
    parts.push(lit);
  }
  return parts.join(' ');
}

function bbAddClause(i, op){
  var clauses = bbEnsure(i);
  clauses.push({ op: op || 'AND', qid: "", opt: "" });
  drawBaseBuilder(i);
}

function bbRemoveClause(i, idx){
  var clauses = bbEnsure(i);
  if (idx >= 0 && idx < clauses.length){
    clauses.splice(idx, 1);
    if (!clauses.length) clauses.push({ op: null, qid: "", opt: "" });
  }
  drawBaseBuilder(i);
}

function bbSet(i, idx, field, value){
  var clauses = bbEnsure(i);
  if (!clauses[idx]) return;
  if (field === 'op')   clauses[idx].op  = value;
  if (field === 'qid') { clauses[idx].qid = value; clauses[idx].opt = ""; }
  if (field === 'opt')  clauses[idx].opt = value;
  drawBaseBuilder(i);
}

function bbApply(i){
  var expr = bbBuildExpr(i);
  if (!expr) return;
  updateBase(i, 'definition', expr);
  var baseInput = document.getElementById('baseDef-' + i);
  if (baseInput) baseInput.value = expr;
  drawBaseBuilder(i);
}

// Draw the rows (one per clause) with AND/OR + Pick Q + Pick Opt
function drawBaseBuilder(i){
  var host = document.getElementById('bbHost-' + i);
  var prev = document.getElementById('bbPrev-' + i);
  if (!host) return;

  var clauses = bbEnsure(i);

  // Build list of prior question ids (only those indexed before i)
  var prior = state.questions.filter(function(_, j){ return j < i; });

  var html = clauses.map(function(c, idx){
    // Build Q options
    var qOpts = ['<option value="">Pick Q</option>']
      .concat(prior.map(function(qq){
        var sel = (qq.id === c.qid) ? ' selected' : '';
        return '<option value="'+ qq.id +'"' + sel + '>'+ qq.id +'</option>';
      })).join('');

    // Build Opt options based on chosen qid
    var chosen = prior.find(function(qq){ return qq.id === c.qid; });
    var opts = (chosen && chosen.options) ? chosen.options : [];
    var oOpts = ['<option value="">Pick option</option>']
      .concat(opts.map(function(o){
        var code = (o && o.code != null) ? o.code : '';
        var sel  = (String(code) === String(c.opt)) ? ' selected' : '';
        var lbl  = escapeHTML(o && o.label ? o.label : '');
        return '<option value="'+ code +'"' + sel + '>'+ code +': '+ lbl +'</option>';
      }))
      .join('');

    // Leading connector (not shown for first row)
    var opSel = (idx === 0)
      ? '<span class="muted" style="min-width:42px; display:inline-block;"></span>'
      : '<select style="min-width:70px" onchange="bbSet('+ i +','+ idx +',\'op\', this.value)">' +
          '<option value="AND"'+ (c.op==='AND'?' selected':'') +'>AND</option>' +
          '<option value="OR"'+  (c.op==='OR' ?' selected':'') +'>OR</option>' +
        '</select>';

    // Row UI
    return '' +
    '<div class="stack" style="gap:8px; align-items:center; width:100%;">' +
      opSel +
      '<select style="flex:1" onchange="bbSet('+ i +','+ idx +',\'qid\', this.value)">'+ qOpts +'</select>' +
      '<select style="flex:1" onchange="bbSet('+ i +','+ idx +',\'opt\', this.value)">'+ oOpts +'</select>' +
      (idx === clauses.length - 1
        ? '<button title="Add clause" onclick="bbAddClause('+ i +', \'AND\')">＋</button>'
        : '<button title="Remove clause" onclick="bbRemoveClause('+ i +','+ idx +')">🗑️</button>') +
    '</div>';
  }).join('');

  host.innerHTML = html;
  if (prev) prev.textContent = bbBuildExpr(i) ? ('Preview: ' + bbBuildExpr(i)) : '';
}


/* =========================================================
   LIBRARY
   ========================================================= */
function getLibrary(){ try{ return JSON.parse(localStorage.getItem(LIB_KEY)||'{}'); } catch{ return {}; } }
function saveLibrary(lib){ localStorage.setItem(LIB_KEY, JSON.stringify(lib)); }
function saveQuestionToLibrary(i){
  const q   = JSON.parse(JSON.stringify(state.questions[i]));
  const key = state.project.client || '_global';
  const lib = getLibrary();
  (lib[key] ||= []).push({ saved_at:new Date().toISOString(), project_id: state.project.id, q });
  saveLibrary(lib);
  alert('Saved to library.');
}
function renderLibrary(root){
  const lib      = getLibrary();
  const clients  = Object.keys(lib).sort();
  root.innerHTML = `
    <section class="app-grid" style="grid-template-columns: 1fr;">
      <div class="card">
        <div class="card-header">
          <strong>Question Library</strong>
          <div class="stack">
            <select id="libClient"></select>
            <button id="libInsert">Insert into current project</button>
            <button id="libDel">Delete selected</button>
          </div>
        </div>
        <div class="card-content"><div class="grid" id="libGrid"></div></div>
      </div>
    </section>`;

  const sel = $('#libClient');
  sel.innerHTML = clients.map(c=>`<option value="${c}">${c}</option>`).join('') || '<option value="_global">_global</option>';
  const grid = $('#libGrid');

  const draw = ()=>{
    const key   = sel.value || clients[0] || '_global';
    const items = lib[key]||[];
    grid.innerHTML = items.map((it,idx)=>`
      <label class="card" style="padding:10px; display:block;">
        <input type="radio" name="libpick" value="${idx}"/>
        <strong>${escapeHTML(it.q.id)} • ${escapeHTML(it.q.type)}</strong>
        <div class="meta">${escapeHTML((it.q.text||'').slice(0,120))}</div>
        <div class="meta">Saved ${new Date(it.saved_at).toLocaleString()}</div>
      </label>
    `).join('') || '<div class="muted">No saved items for this client.</div>';
  };

  sel.onchange = draw;
  draw();

  $('#libInsert').onclick = ()=>{
    const key = sel.value || clients[0] || '_global';
    const idx = +(document.querySelector('input[name="libpick"]:checked')?.value ?? -1);
    if(idx<0) return alert('Pick one');
    const q = JSON.parse(JSON.stringify((lib[key]||[])[idx].q));
    const pref = q.id.startsWith('S') ? 'S':'Q';
    q.id = `${pref}${nextNumber(pref)}`;
    state.questions.push(q);
    ui_state.active_question_index = state.questions.length-1;
    autosaveNow();
    location.hash = '#/editor';
  };

  $('#libDel').onclick = ()=>{
    const key = sel.value || clients[0] || '_global';
    const idx = +(document.querySelector('input[name="libpick"]:checked')?.value ?? -1);
    if(idx<0) return;
    (lib[key]||[]).splice(idx,1);
    saveLibrary(lib);
    draw();
  };
}

/* =========================================================
   RULES (defensive defaults + UI)
   ========================================================= */

const RULES_DEFAULTS = {
  likert:   { single: true,  dual: true,  multi: true  },
  screener: { noNetsOnTerminate: true },
  nets:     { ageMaxInference:  true, hoursDefaultBands: true },
  numeric:  {
    // seconds|minutes|hours|days|weeks|months|years|count|other
    default_unit: "years",
    default_decimals: false,
    default_min: null,
    default_max: null
  }
};

/** Deep fill: ensures state.globals.rules exists and has every leaf. */
function ensureRules(){
  const tgt = (state.globals.rules ||= {});
  const src = RULES_DEFAULTS;

  // leaf-by-leaf merge (avoids clobbering user values)
  tgt.likert   = Object.assign({}, src.likert,   tgt.likert);
  tgt.screener = Object.assign({}, src.screener, tgt.screener);
  tgt.nets     = Object.assign({}, src.nets,     tgt.nets);
  tgt.numeric  = Object.assign({}, src.numeric,  tgt.numeric);

  return tgt;
}

/** Rules screen */
function renderRules(root){
  const r = ensureRules();

  root.innerHTML = `
    <section class="app-grid" style="grid-template-columns: 1fr;">
      <div class="card">
        <div class="card-header"><strong>Rules & Nets Studio</strong></div>
        <div class="card-content">

          <div class="row">
            <div class="k">Likert presets</div>
            <div class="stack">
              <label><input type="checkbox" id="rLikS" ${r.likert.single?'checked':''}/> single → Net: T2B, B2B</label>
              <label><input type="checkbox" id="rLikD" ${r.likert.dual?'checked':''}/> dual → Net: T2B, B2B</label>
              <label><input type="checkbox" id="rLikM" ${r.likert.multi?'checked':''}/> ≥3 stmts → add Q5 summaries</label>
            </div>
          </div>

          <div class="row">
            <div class="k">Screener</div>
            <div class="stack">
              <label><input type="checkbox" id="rScr" ${r.screener.noNetsOnTerminate?'checked':''}/> no nets on terminate options</label>
            </div>
          </div>

          <div class="row">
            <div class="k">Nets engine</div>
            <div class="stack">
              <label><input type="checkbox" id="rAge" ${r.nets.ageMaxInference?'checked':''}/> infer max age from S3</label>
              <label><input type="checkbox" id="rHours" ${r.nets.hoursDefaultBands?'checked':''}/> default hours bands</label>
            </div>
          </div>

          <div class="row">
            <div class="k">Numeric defaults</div>
            <div class="stack" style="align-items:flex-end">
              <label>Unit
                <select id="rNumUnit" style="min-width:160px">
                  ${["years","months","weeks","days","hours","minutes","seconds","count","other"]
                    .map(u=>`<option ${r.numeric.default_unit===u?'selected':''}>${u}</option>`).join("")}
                </select>
              </label>
              <label><input type="checkbox" id="rNumDec" ${r.numeric.default_decimals?'checked':''}/> allow decimals</label>
              <label>Min <input id="rNumMin" type="number" step="any" value="${r.numeric.default_min ?? ''}" placeholder="(none)" style="width:120px"/></label>
              <label>Max <input id="rNumMax" type="number" step="any" value="${r.numeric.default_max ?? ''}" placeholder="(none)" style="width:120px"/></label>
            </div>
          </div>

          <div class="stack"><button id="saveRules" class="primary">Save</button></div>
        </div>
      </div>
    </section>`;

  // Save & autosave
  $('#saveRules').onclick = ()=>{
    const rr = ensureRules(); // ensure structure still intact

    rr.likert.single = $('#rLikS').checked;
    rr.likert.dual   = $('#rLikD').checked;
    rr.likert.multi  = $('#rLikM').checked;

    rr.screener.noNetsOnTerminate = $('#rScr').checked;

    rr.nets.ageMaxInference   = $('#rAge').checked;
    rr.nets.hoursDefaultBands = $('#rHours').checked;

    rr.numeric.default_unit     = $('#rNumUnit').value;
    rr.numeric.default_decimals = $('#rNumDec').checked;

    const minV = $('#rNumMin').value, maxV = $('#rNumMax').value;
    rr.numeric.default_min = (minV==='' ? null : Number(minV));
    rr.numeric.default_max = (maxV==='' ? null : Number(maxV));

    queueAutosave();
    setStatus('Rules saved.', true);
    alert('Saved');
  };
}

/* =========================================================
   VALIDATOR
   ========================================================= */
function validateProject(){
  const issues = [];

  // 0) mode sanity (expect list|numeric|table)
  state.questions.forEach(q=>{
    if(q.mode && !['list','numeric','table','open'].includes(q.mode)){
      issues.push(["red", `${q.id}: invalid mode "${q.mode}" (must be list | numeric | table | open)`]);
    }
  });

  // 1) codes & labels
  state.questions.forEach((q)=>{
    const codes  = (q.options||[]).map(o=>o.code).filter(v=>v!==undefined && v!==null && v!=='');
    const labels = (q.options||[]).map(o=>o.label||'');
    const dup    = codes.filter((v,i,a)=> a.indexOf(v)!==i);
    if(dup.length) issues.push(["red", `${q.id}: duplicate codes ${[...new Set(dup)].join(', ')}`]);
    if(codes.length){
      const sorted=[...codes].sort((a,b)=>a-b);
      for(let i=1;i<sorted.length;i++){
        if(sorted[i]-sorted[i-1]>1){ issues.push(["amber", `${q.id}: code gap between ${sorted[i-1]} and ${sorted[i]}`]); break; }
      }
    }
    labels.forEach((l,li)=>{ if(!String(l).trim()) issues.push(["red", `${q.id}: option ${li+1} missing label`]); });
  });

  // 1b) numeric config
  const validUnits = new Set(["seconds","minutes","hours","days","weeks","months","years","count","other",""]);
  state.questions.forEach(q=>{
    const isNumeric = q.mode==='numeric' || (q.type||'').startsWith('numeric');
    if(!isNumeric) return;
    const n = q.numeric || {};
    if(n.unit && !validUnits.has(n.unit)) issues.push(["red", `${q.id}: invalid numeric unit "${n.unit}"`]);
    if(n.min!=null && n.max!=null && Number(n.min) > Number(n.max)) issues.push(["red", `${q.id}: numeric min > max`]);
    if(n.placeholder && typeof n.placeholder !== 'string') issues.push(["amber", `${q.id}: numeric placeholder should be text`]);
  });

  // 1c) open-end config
  state.questions.forEach(q=>{
    if(q.mode === 'open'){
      const k = q.open?.limit_kind;
      if (k && !['words','characters','sentences'].includes(k)){
        issues.push(['amber', `${q.id}: invalid open limit kind "${k}"`]);
      }
      const {min, max} = q.open || {};
      if (min!=null && max!=null && Number(min) > Number(max)){
        issues.push(['amber', `${q.id}: open min > max`]);
      }
    }
  });


  // 2) bases referencing future questions
  state.questions.forEach((q,qi)=>{
    const def = q.base?.definition||'';
    const m = def.match(/^(S\d+|Q\d+)[^\d]*\[(\d+)\]/i);
    if(m){
      const refId  = m[1];
      const refIdx = state.questions.findIndex(x=>x.id===refId);
      if(refIdx>qi) issues.push(["red", `${q.id}: base references future question ${refId}`]);
    }
  });

  // 3) likert mismatches
  state.questions.forEach(q=>{
    if(q.scale?.points && q.scale.labels && q.scale.labels.length && q.scale.labels.length !== q.scale.points){
      issues.push(["amber", `${q.id}: ${q.scale.points}pt but ${q.scale.labels.length} labels`]);
    }
  });

  // 4) terminate included in nets
  state.questions.forEach(q=>{
    const hasTerm = (q.options||[]).some(o=>o.terminate);
    if(hasTerm && (q.exports?.tab_plan?.nets_text||'').trim()){
      issues.push(["amber", `${q.id}: has terminate options but nets text present`]);
    }
  });

  return issues;
}
function renderValidator(root){
  const issues = validateProject();
  root.innerHTML = `
    <section class="app-grid" style="grid-template-columns: 1fr;">
      <div class="card">
        <div class="card-header">
          <strong>Validator</strong>
          <div class="pill">${issues.length? issues.length+" issues" : "All checks passed"}</div>
        </div>
        <div class="card-content">
          ${
            issues.length
              ? issues.map(([sev,msg])=>`<div class="stack"><span class="pill" style="${sev==='red'?'background:#fee2e2;':''}${sev==='amber'?'background:#fef9c3;':''}">${sev.toUpperCase()}</span><span>${escapeHTML(msg)}</span></div>`).join('')
              : '<div class="ok">No blocking issues detected.</div>'
          }
          <div class="stack" style="margin-top:12px;"><button onclick="location.hash='#/editor'">Go to Editor</button></div>
        </div>
      </div>
    </section>`;
}

/* =========================================================
   VERSIONS / SNAPSHOTS
   ========================================================= */
function getSnapshotsMap(){ try{ return JSON.parse(localStorage.getItem(SNAP_KEY)||'{}'); } catch{ return {}; } }
function saveSnapshotsMap(map){ localStorage.setItem(SNAP_KEY, JSON.stringify(map)); }
function snapshotCurrent(note=''){
  const map  = getSnapshotsMap();
  const pid  = state.project.id;
  const snap = {
    id: 'snap-' + Math.random().toString(16).slice(2,10),
    ts: new Date().toISOString(),
    note,
    project: JSON.parse(JSON.stringify(state))
  };
  (map[pid] ||= []).unshift(snap);
  saveSnapshotsMap(map);
  setStatus('Snapshot saved.', true);
  return snap;
}
function restoreSnapshot(id, byId){
  const snap = byId?.[id] || (getSnapshotsMap()[state.project.id]||[]).find(s=>s.id===id);
  if(!snap) return;
  if(!confirm('Restore this snapshot? Your current unsaved changes will be replaced.')) return;
  state.project   = snap.project.project;
  state.globals   = snap.project.globals;
  state.questions = snap.project.questions;
  autosaveNow();
  touchCurrentIntoProjects();
  location.hash = '#/editor';
}
function renderVersions(root){
  const map   = getSnapshotsMap();
  const pid   = state.project.id;
  const snaps = map[pid] || [];
  root.innerHTML = `
    <section class="app-grid" style="grid-template-columns: 1fr;">
      <div class="card">
        <div class="card-header">
          <strong>Versions & Diff</strong>
          <div class="stack">
            <input id="snapNote" placeholder="Snapshot note (optional)" style="width:240px"/>
            <button id="makeSnap" class="primary">📸 Snapshot</button>
          </div>
        </div>
        <div class="card-content">
          ${snaps.length ? `
            <div class="stack" style="flex-wrap:wrap;">
              <select id="snapA">${snaps.map(s=>`<option value="${s.id}">${new Date(s.ts).toLocaleString()} — ${escapeHTML(s.note||'')}</option>`).join('')}</select>
              <span>↔</span>
              <select id="snapB">${snaps.map(s=>`<option value="${s.id}">${new Date(s.ts).toLocaleString()} — ${escapeHTML(s.note||'')}</option>`).join('')}</select>
              <button id="doDiff">Compare</button>
              <button id="restoreA">Restore A</button>
              <button id="restoreB">Restore B</button>
              <button id="deleteA">Delete A</button>
            </div>
            <div id="diffOut" class="diff" style="margin-top:12px; white-space:pre-wrap;"></div>
          ` : `<div class="muted">No snapshots yet.</div>`}
        </div>
      </div>
    </section>`;

  $('#makeSnap').onclick = ()=>{
    snapshotCurrent($('#snapNote').value.trim());
    renderVersions(root);
  };
  if(!snaps.length) return;

  const byId = Object.fromEntries(snaps.map(s=>[s.id,s]));
  $('#doDiff').onclick    = ()=>{ const a = byId[$('#snapA').value]; const b = byId[$('#snapB').value]; if(!a||!b) return; $('#diffOut').innerHTML = prettyJsonDiff(a.project, b.project); };
  $('#restoreA').onclick  = ()=> restoreSnapshot($('#snapA').value, byId);
  $('#restoreB').onclick  = ()=> restoreSnapshot($('#snapB').value, byId);
  $('#deleteA').onclick   = ()=>{
    const id  = $('#snapA').value;
    const idx = snaps.findIndex(s=>s.id===id);
    if(idx>=0 && confirm('Delete snapshot A?')){
      snaps.splice(idx,1);
      saveSnapshotsMap(map);
      renderVersions(root);
    }
  };
}
/* Simple JSON diff (line-based) */
function prettyJsonDiff(a,b){
  const A = JSON.stringify(a, null, 2).split('\n');
  const B = JSON.stringify(b, null, 2).split('\n');
  const max = Math.max(A.length, B.length);
  const out = [];
  for(let i=0;i<max;i++){
    const l = A[i] ?? '', r = B[i] ?? '';
    if(l===r){ out.push(escapeHTML(l)); }
    else{ if(l) out.push('<del>− ' + escapeHTML(l) + '</del>'); if(r) out.push('<ins>+ ' + escapeHTML(r) + '</ins>'); }
  }
  return out.join('\n');
}

/* =========================================================
   IMPORT / EXPORT / GENERATE
   ========================================================= */
function downloadJSON(){
  state.project.updated_at = new Date().toISOString();
  const data = JSON.stringify({ project: state.project, globals: state.globals, questions: state.questions }, null, 2);
  const blob = new Blob([data], {type:"application/json"});
  const a    = document.createElement("a");
  a.href     = URL.createObjectURL(blob);
  a.download = `${(state.project.name||'project').replace(/[^\w\-]+/g,'_')}.json`;
  a.click();
  URL.revokeObjectURL(a.href);
}
$('#downloadJson').onclick = downloadJSON;

$('#importJson').onclick = ()=>{
  const inp = document.createElement("input");
  inp.type = "file"; 
  inp.accept = "application/json";

  inp.onchange = async (e)=>{
    const file = e.target.files[0]; 
    if(!file) return;

    const data = JSON.parse(await file.text());

    state.project   = data.project   || state.project || {};
    state.globals   = data.globals   || state.globals || {};
    state.questions = Array.isArray(data.questions) ? data.questions : [];

    // <<< NEW: upgrade imported project >>>
    migrateProjectModel?.();

    ui_state.active_question_index = state.questions.length ? 0 : null;

    renderRoute?.(); 
    autosaveNow?.(); 
    setStatus?.("Loaded JSON.", true);
    touchCurrentIntoProjects?.();
  };
  inp.click();
};

async function postAndDownload(url, filename){
  $("#serverError").style.display="none";
  setStatus("Generating...", false);
  try{
    const res = await fetch(url, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ project: state.project, globals: state.globals, questions: state.questions })
    });
    if(!res.ok){ throw new Error(await res.text() || `HTTP ${res.status}`); }
    const blob = await res.blob();
    const a    = document.createElement("a");
    a.href     = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(a.href);
    setStatus("Download complete.", true);
  }catch(err){
    $("#serverError").textContent = "Server error:\n\n" + err.message;
    $("#serverError").style.display="block";
    setStatus("Generation failed.", false);
  }
}
$('#generateXlsx').onclick = ()=> postAndDownload("/generate/tab-plan",      `${(state.project.name||'project').replace(/[^\w\-]+/g,'_')}_tab_plan.xlsx`);
$('#generateDocx').onclick = ()=> postAndDownload("/generate/questionnaire", `${(state.project.name||'project').replace(/[^\w\-]+/g,'_')}_questionnaire.docx`);

/* =========================================================
   AUTOSAVE
   ========================================================= */
function autosaveNow(){
  try{
    localStorage.setItem(AUTOSAVE_KEY, JSON.stringify({ project: state.project, globals: state.globals, questions: state.questions }));
    localStorage.setItem(`proj:${state.project.id}`, JSON.stringify({ project: state.project, globals: state.globals, questions: state.questions }));
    touchCurrentIntoProjects();
    setStatus("Autosaved.", true);
  }catch(e){ console.warn("Autosave failed", e); }
}
let _asTimer=null;
function queueAutosave(){ clearTimeout(_asTimer); _asTimer=setTimeout(autosaveNow, 600); }
document.addEventListener("input",  queueAutosave, true);
document.addEventListener("change", queueAutosave, true);

function loadAutosave(){
  const s = localStorage.getItem(AUTOSAVE_KEY);
  if(!s) return false;
  const d = JSON.parse(s);
  state.project   = d.project   || state.project;
  state.globals   = d.globals   || state.globals;
  state.questions = d.questions || [];
  ensureRules();
  ui_state.active_question_index = state.questions.length? 0 : null;
  return true;
}

// ---------------- ROUTING TABLE + RENDERER (hardened) ----------------

// 1) Register pages
routes.clear?.(); // clean slate if a previous bundle populated it
routes.set('#/dashboard', renderDashboard);
routes.set('#/editor',    renderEditor);

// simple stubs (wire later)
routes.set('#/library',   renderLibrary);
routes.set('#/rules',     renderRules);
routes.set('#/validator', renderValidator);
routes.set('#/versions',  renderVersions);

// 2) Helpers
function normalizeHash(h) {
  const hash = h || location.hash || '#/dashboard';
  // collapse editor subtabs to #/editor (keep subtab separately)
  if (hash.startsWith('#/editor/')) return '#/editor';
  return hash;
}
function getSubtabFromHash(h) {
  const parts = (h || location.hash || '').split('/');
  return parts[2] || null; // e.g., '#/editor/pre' -> 'pre'
}

// 3) Subtab controller (visibility + active state)
function updateSubtabsVisibilityAndState() {
  const bar = document.getElementById('editor-subtabs');
  if (!bar) return;

  const onEditor = (normalizeHash() === '#/editor');
  const hasProject = !!state?.project?.id;

  // Show/hide the sticky bar
  bar.classList.toggle('is-hidden', !(onEditor && hasProject));

  // Handle L2 sub-panel visibility
  const editorPanelsContainer = document.getElementById('editor-panels');
  if (editorPanelsContainer) {
      if (!(onEditor && hasProject)) {
          editorPanelsContainer.classList.add('is-hidden');
          return;
      }
      editorPanelsContainer.classList.remove('is-hidden');

      const valid = new Set(['pre','field','report','post']);
      const sub = valid.has(getSubtabFromHash()) ? getSubtabFromHash() : 'pre';

      bar.querySelectorAll('.subtab').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.subtab === sub);
      });

      ['pre','field','report','post'].forEach(p => {
        const el = document.getElementById('panel-' + p);
        if (el) el.classList.toggle('is-hidden', p !== sub);
      });
  }
}


// 4) Main router
function renderRoute() {
  const root = document.getElementById('view-root');
  const err  = document.getElementById('serverError');
  if (!root) return;

  try {
    const key  = normalizeHash(location.hash);
    const view = routes.get(key) || renderDashboard;

    // This handles the L2 subtabs (Pre-field, Fielding, etc.)
    updateSubtabsVisibilityAndState();

    if (err) { err.style.display = 'none'; err.textContent = ''; }
    // The view function (e.g., renderEditor) is now responsible for populating `root`.
    view(root);
    refreshSidebarProjects();
    highlightNav?.();
  } catch (e) {
    console.error(e);
    if (err) {
      err.style.display = 'block';
      err.textContent = (e && e.stack) ? e.stack : String(e);
    }
    try { renderDashboard(root); } catch(_) {}
  }
}

// 5) Bootstrap (safe; don’t blow up if ensureRules was nuked)
(function bootstrap(){
  if (typeof ensureRules === 'function') ensureRules();
  const s = localStorage.getItem(AUTOSAVE_KEY);
  if (s && typeof loadAutosave === 'function' && confirm('Restore your last autosaved session?')) {
    loadAutosave();
  }
  renderRoute();
})();

// 6) Events
window.addEventListener('hashchange', renderRoute);
window.addEventListener('DOMContentLoaded', renderRoute);

// optional: editor inner tabs fallback
document.addEventListener('click', (e) => {
  const btn = e.target.closest('.editor-tabs [data-tab]');
  if (!btn) return;
  if (typeof setActiveTab === 'function') {
    setActiveTab(btn.dataset.tab);
  } else {
    // minimal fallback if helper isn’t defined
    ui_state.active_tab = btn.dataset.tab;
    renderEditorPanel?.();
  }
});
</script>
<div id="toastHost" aria-live="polite" style="position:fixed; inset:auto 16px 16px auto; z-index:1100;"></div>
<script>
// Side Drawer → Preview panel switching
// Side Drawer → Preview panel switching
(function(){
  const drawer = document.getElementById('sideDrawer');

  // NEW, CORRECTED click handler for drawer links
  drawer?.addEventListener('click', (e) => {
    const btn = e.target.closest('.sd-link');
    if (!btn) return;

    // route jumps (Editor / Rules / Validator etc.)
    const goto = btn.getAttribute('data-goto');
    if (goto){
      location.hash = goto;
      return;
    }

    // preview tab switching
    const id = btn.getAttribute('data-pvtab'); // "scr" | "main" | "tab" | "ban"
    if (!id) return;

    // --- THIS IS THE FIX ---
    // 1. Map the short ID to the state variable's value
    const map = { scr: 'screener', main: 'main', tab: 'tabplan', ban: 'banner' };
    const nextTab = map[id];

    if (nextTab && window.ui_state) {
      // 2. Update the application's state
      ui_state.active_prefield_tab = nextTab;

      // 3. Trigger a full re-render of the editor view
      // This ensures the layout changes correctly (e.g., from 2-panel to 1-panel)
      if (typeof renderEditor === 'function' && isEditorRoute()) {
        const root = document.getElementById('view-root');
        if (root) renderEditor(root);
      }
    }

    // Highlight the drawer selection
    drawer.querySelectorAll('.sd-link[data-pvtab]').forEach(d => {
      d.classList.toggle('active', d.dataset.pvtab === id);
    });
  });

  // If user clicks the old top pills, mirror state into drawer
  document.addEventListener('click', (e)=>{
    const t = e.target.closest('.pv-tab');
    if (!t) return;
    const id = t.dataset.pvtab;
    drawer?.querySelectorAll('.sd-link[data-pvtab]').forEach(d => {
      d.classList.toggle('active', d.dataset.pvtab === id);
    });
  });
})();
</script>
</body>
</html>