-- 0005a_flexible_embeddings.sql
-- Support flexible embedding dimensions (768 for nomic, 1024 for bge-m3)

-- Drop existing table if it exists (only safe if no data yet)
-- If you have data, skip this and manually alter the dimension

DROP TABLE IF EXISTS knowledge_base CASCADE;

-- Recreate with 768 dimensions (nomic-embed-text default)
CREATE TABLE IF NOT EXISTS knowledge_base (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,

  -- Content
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  category TEXT NOT NULL,
  tags TEXT[] DEFAULT '{}',

  -- Vector search - 768 dimensions for nomic-embed-text
  -- Change to vector(1024) if using bge-m3
  embedding vector(768),

  -- Source tracking
  source_type TEXT,
  source_reference TEXT,

  -- Metadata
  author_id UUID REFERENCES people(id) ON DELETE SET NULL,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for vector similarity search
CREATE INDEX ON knowledge_base USING ivfflat (embedding vector_cosine_ops)
  WITH (lists = 100);

-- Full-text search index
CREATE INDEX knowledge_base_content_fts ON knowledge_base
  USING gin(to_tsvector('english', title || ' ' || content));

-- Update search function for 768 dimensions
DROP FUNCTION IF EXISTS search_knowledge_base;

CREATE OR REPLACE FUNCTION search_knowledge_base(
  query_embedding vector(768),  -- Match your embedding dimensions
  match_threshold FLOAT DEFAULT 0.7,
  match_count INT DEFAULT 5
)
RETURNS TABLE (
  id UUID,
  title TEXT,
  content TEXT,
  category TEXT,
  similarity FLOAT
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    kb.id,
    kb.title,
    kb.content,
    kb.category,
    1 - (kb.embedding <=> query_embedding) AS similarity
  FROM knowledge_base kb
  WHERE kb.is_active = TRUE
    AND 1 - (kb.embedding <=> query_embedding) > match_threshold
  ORDER BY kb.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

-- Re-insert seed knowledge (without embeddings - will be generated by Python)
INSERT INTO knowledge_base (title, content, category, tags, source_type) VALUES
(
  'Survey Question Best Practices',
  'When designing survey questions:
  1. Keep questions clear and concise
  2. Avoid leading or loaded questions
  3. Use simple, everyday language
  4. Avoid double-barreled questions (asking two things at once)
  5. Provide mutually exclusive response options
  6. Consider scale direction (positive to negative or vice versa)
  7. Test questions with target audience before fielding',
  'questionnaire_design',
  ARRAY['best_practices', 'survey_design', 'question_writing'],
  'manual'
),
(
  'Banner Design Fundamentals',
  'Banners define subgroups for cross-tabulation:
  - H1 categories are major demographic/behavioral splits (Gender, Age, Usage)
  - H2 categories are subcategories within H1 (Male/Female within Gender)
  - Use equations for conditions (e.g., S7=2 for a specific response)
  - Common banner types: Demographics, Product Usage, Attitudes, Behaviors
  - Keep banner count manageable (typically 5-15 H1 categories)
  - Ensure sufficient base sizes for statistical validity',
  'banner_tips',
  ARRAY['banners', 'crosstabs', 'data_tables', 'analysis'],
  'manual'
),
(
  'Tab Sheet Structure',
  'Tab sheets define the table plan for data analysis:
  - Each row typically represents one data table
  - Specify base definition (who is included in percentages)
  - Define nets (grouped responses) for summary analysis
  - Include special instructions (means, medians, statistical testing)
  - Banners form the columns of each table
  - Clear labeling prevents analyst confusion during programming',
  'data_analysis',
  ARRAY['tab_sheets', 'data_tables', 'reporting', 'analysis_plan'],
  'manual'
),
(
  'Statistical Significance Testing',
  'When conducting market research analysis:
  - Use 90%, 95%, or 99% confidence levels (90% most common in MR)
  - Compare subgroups using appropriate tests (z-test for proportions, t-test for means)
  - Account for multiple comparisons (Bonferroni correction if needed)
  - Ensure adequate base sizes (nâ‰¥30 minimum for most tests)
  - Report statistically significant differences clearly
  - Consider practical significance alongside statistical significance',
  'data_analysis',
  ARRAY['statistics', 'significance_testing', 'analysis', 'reporting'],
  'manual'
),
(
  'Conditional Logic Patterns',
  'Common conditional logic use cases:
  - Display questions only to relevant respondents
  - Skip patterns based on screening criteria
  - Pipe text from previous responses
  - Randomize order while maintaining exclusivity
  - Show follow-up questions based on previous answers
  - Use operators: = (equals), != (not equals), > (greater than), < (less than)
  - Combine conditions with AND/OR logic for complex scenarios',
  'questionnaire_design',
  ARRAY['conditional_logic', 'skip_patterns', 'survey_flow', 'programming'],
  'manual'
),
(
  'SPSS Data File Best Practices',
  'When working with SPSS data:
  - Use variable names that match question IDs (Q1, S1, etc.)
  - Set proper variable labels (full question text)
  - Define value labels for all coded responses
  - Set measurement level correctly (nominal, ordinal, scale)
  - Use numeric codes for categorical data
  - Store dates in SPSS date format
  - Document recodes and computed variables
  - Save metadata alongside data file',
  'spss',
  ARRAY['spss', 'data_management', 'coding', 'metadata'],
  'manual'
);
